<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DIDLab â€” AgriSensor DApp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #0b1320;
      color: #e6eaf2;
    }
    .wrap {
      max-width: 1200px;
      margin: 40px auto;
      padding: 24px;
      border: 1px solid #24314a;
      border-radius: 14px;
      background: #0f1a2b;
    }
    h1 {
      margin: 0 0 16px;
      font-size: 22px;
    }
    h3 {
      margin: 16px 0 8px;
      font-size: 16px;
    }
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 8px 0;
    }
    .row > * {
      flex: 1;
      min-width: 200px;
    }
    input, select, button, textarea {
      padding: 10px 12px;
      border: 1px solid #314164;
      background: #0b1527;
      color: #e6eaf2;
      border-radius: 10px;
      font-family: inherit;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
    }
    button {
      cursor: pointer;
    }
    button.primary {
      background: #335cff;
      border-color: #335cff;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .card {
      padding: 16px;
      border: 1px solid #24314a;
      border-radius: 10px;
      background: #0b1527;
      margin: 12px 0;
    }
    .muted {
      opacity: .8;
    }
    .ok {
      color: #7be07b;
    }
    .warn {
      color: #ffd166;
    }
    .err {
      color: #ff6b6b;
    }
    a {
      color: #9bc1ff;
    }
    .kvs {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 8px;
    }
    .kvs div {
      padding: 6px 8px;
      border-bottom: 1px dashed #22314e;
    }
    .tabs {
      display: flex;
      gap: 8px;
      margin: 16px 0;
      border-bottom: 2px solid #24314a;
    }
    .tab {
      padding: 10px 16px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #8a9bb8;
      border-radius: 10px 10px 0 0;
    }
    .tab.active {
      background: #0b1527;
      color: #e6eaf2;
      border-bottom: 2px solid #335cff;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 12px 0;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #24314a;
    }
    th {
      background: #0b1527;
      font-weight: 600;
    }
    .small {
      font-size: 13px;
    }
    label {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸŒ¾ DIDLab â€” AgriSensor DApp</h1>
    
    <!-- CONFIG -->
    <div class="card">
      <div class="row">
        <div>
          <label>Network</label>
          <select id="team">
            <option value="00">DIDLab Main (252501)</option>
            <!-- Add more networks here as needed -->
          </select>
        </div>
        <div>
          <label>Sensor Contract Address</label>
          <input id="contractAddr" class="mono" placeholder="0x..." />
        </div>
      </div>
      <div class="row">
        <button id="btnConnect" class="primary">1) Connect & Switch Network</button>
        <button id="btnLoad">2) Load Contract</button>
        <button id="btnRefresh">Refresh Stats</button>
      </div>
    </div>
    
    <!-- STATUS -->
    <div class="card">
      <div class="kvs">
        <div class="muted">Account</div>
        <div id="acct" class="mono">â€”</div>
        <div class="muted">Network</div>
        <div id="net" class="mono">â€”</div>
        <div class="muted">Contract</div>
        <div id="contractInfo" class="mono">â€”</div>
        <div class="muted">Total Readings</div>
        <div id="totalReadings" class="mono">â€”</div>
        <div class="muted">Total Crop Events</div>
        <div id="totalEvents" class="mono">â€”</div>
        <div class="muted">Total Supply Chain Stages</div>
        <div id="totalStages" class="mono">â€”</div>
      </div>
    </div>

    <!-- TABS -->
    <div class="tabs">
      <button class="tab active" data-tab="submit">Submit Sensor Data</button>
      <button class="tab" data-tab="view">View Readings</button>
      <button class="tab" data-tab="crop">Crop Events</button>
      <button class="tab" data-tab="supply">Supply Chain</button>
      <button class="tab" data-tab="roles">Manage Roles</button>
    </div>

    <!-- TAB: SUBMIT SENSOR DATA -->
    <div id="tab-submit" class="tab-content active">
      <div class="card">
        <h3>Submit Single Reading</h3>
        <div class="row">
          <div>
            <label>Farm ID</label>
            <input id="farmId" type="number" placeholder="e.g. 1" value="1" />
          </div>
          <div>
            <label>Temperature (Â°C)</label>
            <input id="temp" type="number" step="0.1" placeholder="e.g. 25.5" />
          </div>
          <div>
            <label>Soil Moisture (%)</label>
            <input id="moisture" type="number" step="0.1" placeholder="e.g. 45.2" />
          </div>
          <div>
            <label>Humidity (%)</label>
            <input id="humidity" type="number" step="0.1" placeholder="e.g. 60.5" />
          </div>
        </div>
        <button id="btnSubmit" class="primary">Submit Reading</button>
      </div>

      <div class="card">
        <h3>Submit Batch (for IoT Gateways)</h3>
        <p class="muted small">Enter comma-separated values. All arrays must have the same length.</p>
        <div class="row">
          <div>
            <label>Farm IDs (comma-separated)</label>
            <input id="batchFarms" placeholder="1,1,2,2" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Temperatures (Â°C)</label>
            <input id="batchTemps" placeholder="25.5,26.0,24.8,25.2" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Soil Moisture (%)</label>
            <input id="batchMoisture" placeholder="45.2,46.0,44.5,45.8" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Humidity (%)</label>
            <input id="batchHumidity" placeholder="60.5,61.2,59.8,60.9" />
          </div>
        </div>
        <button id="btnBatch" class="primary">Submit Batch</button>
      </div>
    </div>

    <!-- TAB: VIEW READINGS -->
    <div id="tab-view" class="tab-content">
      <div class="card">
        <h3>Query Readings</h3>
        <div class="row">
          <div>
            <label>Farm ID</label>
            <input id="queryFarm" type="number" placeholder="1" value="1" />
          </div>
          <button id="btnQuery">Get Readings for Farm</button>
        </div>
        <div id="readingsTable"></div>
      </div>
    </div>

    <!-- TAB: CROP EVENTS -->
    <div id="tab-crop" class="tab-content">
      <div class="card">
        <h3>Record Crop Event</h3>
        <div class="row">
          <div>
            <label>Farm ID</label>
            <input id="cropFarmId" type="number" placeholder="1" value="1" />
          </div>
          <div>
            <label>Event Type</label>
            <select id="cropEventType">
              <option>SEED</option>
              <option>FERTILIZE</option>
              <option>IRRIGATE</option>
              <option>HARVEST</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Notes</label>
            <textarea id="cropNotes" placeholder="Additional details..."></textarea>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Linked Data Hash (optional)</label>
            <input id="cropHash" class="mono" placeholder="0x0000..." value="0x0000000000000000000000000000000000000000000000000000000000000000" />
          </div>
        </div>
        <button id="btnCropEvent" class="primary">Record Event</button>
      </div>

      <div class="card">
        <h3>View Crop Events</h3>
        <div class="row">
          <div>
            <label>Farm ID</label>
            <input id="queryCropFarm" type="number" placeholder="1" value="1" />
          </div>
          <button id="btnQueryCrop">Get Events for Farm</button>
        </div>
        <div id="cropEventsTable"></div>
      </div>
    </div>

    <!-- TAB: SUPPLY CHAIN -->
    <div id="tab-supply" class="tab-content">
      <div class="card">
        <h3>Record Supply Chain Stage</h3>
        <div class="row">
          <div>
            <label>Product ID</label>
            <input id="productId" type="number" placeholder="1001" />
          </div>
          <div>
            <label>Stage</label>
            <select id="stage">
              <option>FARM</option>
              <option>TRANSPORT</option>
              <option>STORAGE</option>
              <option>RETAIL</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Location</label>
            <input id="location" placeholder="Kansas City Warehouse" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Linked Data Hash (optional)</label>
            <input id="stageHash" class="mono" placeholder="0x0000..." value="0x0000000000000000000000000000000000000000000000000000000000000000" />
          </div>
        </div>
        <button id="btnStage" class="primary">Record Stage</button>
      </div>

      <div class="card">
        <h3>View Supply Chain</h3>
        <div class="row">
          <div>
            <label>Product ID</label>
            <input id="queryProduct" type="number" placeholder="1001" />
          </div>
          <button id="btnQuerySupply">Get Stages for Product</button>
        </div>
        <div id="supplyTable"></div>
      </div>
    </div>

    <!-- TAB: MANAGE ROLES -->
    <div id="tab-roles" class="tab-content">
      <div class="card">
        <h3>Grant Role</h3>
        <p class="muted small">Only admin can grant roles.</p>
        <div class="row">
          <div>
            <label>Role</label>
            <select id="grantRole">
              <option value="DEVICE_ROLE">DEVICE_ROLE</option>
              <option value="FARMER_ROLE">FARMER_ROLE</option>
              <option value="RESEARCHER_ROLE">RESEARCHER_ROLE</option>
              <option value="SUPPLY_CHAIN_ROLE">SUPPLY_CHAIN_ROLE</option>
            </select>
          </div>
          <div>
            <label>Address</label>
            <input id="grantAddr" class="mono" placeholder="0x..." />
          </div>
        </div>
        <button id="btnGrant" class="primary">Grant Role</button>
      </div>

      <div class="card">
        <h3>Revoke Role</h3>
        <div class="row">
          <div>
            <label>Role</label>
            <select id="revokeRole">
              <option value="DEVICE_ROLE">DEVICE_ROLE</option>
              <option value="FARMER_ROLE">FARMER_ROLE</option>
              <option value="RESEARCHER_ROLE">RESEARCHER_ROLE</option>
              <option value="SUPPLY_CHAIN_ROLE">SUPPLY_CHAIN_ROLE</option>
            </select>
          </div>
          <div>
            <label>Address</label>
            <input id="revokeAddr" class="mono" placeholder="0x..." />
          </div>
        </div>
        <button id="btnRevoke" class="primary">Revoke Role</button>
      </div>
    </div>

    <!-- LOG -->
    <div class="card">
      <h3>Transaction Log</h3>
      <div id="txlog" class="mono small"></div>
    </div>
    
    <p class="muted small">Tip: values persist in localStorage.</p>
  </div>

  <script type="module">
    import {
      createPublicClient,
      createWalletClient,
      custom,
      getAddress,
      keccak256,
      toHex
    } from "https://esm.sh/viem@2.37.5";

    // ===== AgriSensorData ABI (essential functions)
    const SENSOR_ABI = [
      {
        type: "function",
        name: "submitSensorData",
        stateMutability: "nonpayable",
        inputs: [
          { name: "farmId", type: "uint256" },
          { name: "temperature", type: "int16" },
          { name: "soilMoisture", type: "uint16" },
          { name: "humidity", type: "uint16" }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "submitBatch",
        stateMutability: "nonpayable",
        inputs: [
          { name: "farmIds", type: "uint256[]" },
          { name: "temperatures", type: "int16[]" },
          { name: "moistures", type: "uint16[]" },
          { name: "humidities", type: "uint16[]" }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "recordCropEvent",
        stateMutability: "nonpayable",
        inputs: [
          { name: "farmId", type: "uint256" },
          { name: "eventType", type: "string" },
          { name: "notes", type: "string" },
          { name: "linkedDataHash", type: "bytes32" }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "recordSupplyChainStage",
        stateMutability: "nonpayable",
        inputs: [
          { name: "productId", type: "uint256" },
          { name: "stage", type: "string" },
          { name: "location", type: "string" },
          { name: "linkedDataHash", type: "bytes32" }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "getReadingsByFarm",
        stateMutability: "view",
        inputs: [{ name: "farmId", type: "uint256" }],
        outputs: [{ type: "uint256[]" }]
      },
      {
        type: "function",
        name: "getCropEventsByFarm",
        stateMutability: "view",
        inputs: [{ name: "farmId", type: "uint256" }],
        outputs: [{ type: "uint256[]" }]
      },
      {
        type: "function",
        name: "getSupplyChainStages",
        stateMutability: "view",
        inputs: [{ name: "productId", type: "uint256" }],
        outputs: [{ type: "uint256[]" }]
      },
      {
        type: "function",
        name: "readings",
        stateMutability: "view",
        inputs: [{ name: "", type: "uint256" }],
        outputs: [
          { name: "timestamp", type: "uint256" },
          { name: "deviceId", type: "address" },
          { name: "farmId", type: "uint256" },
          { name: "temperature", type: "int16" },
          { name: "soilMoisture", type: "uint16" },
          { name: "humidity", type: "uint16" },
          { name: "dataHash", type: "bytes32" }
        ]
      },
      {
        type: "function",
        name: "cropEvents",
        stateMutability: "view",
        inputs: [{ name: "", type: "uint256" }],
        outputs: [
          { name: "farmId", type: "uint256" },
          { name: "eventType", type: "string" },
          { name: "timestamp", type: "uint256" },
          { name: "notes", type: "string" },
          { name: "linkedDataHash", type: "bytes32" }
        ]
      },
      {
        type: "function",
        name: "supplyChainStages",
        stateMutability: "view",
        inputs: [{ name: "", type: "uint256" }],
        outputs: [
          { name: "productId", type: "uint256" },
          { name: "stage", type: "string" },
          { name: "timestamp", type: "uint256" },
          { name: "recorder", type: "address" },
          { name: "location", type: "string" },
          { name: "linkedDataHash", type: "bytes32" }
        ]
      },
      {
        type: "function",
        name: "getTotalReadings",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: "uint256" }]
      },
      {
        type: "function",
        name: "getTotalCropEvents",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: "uint256" }]
      },
      {
        type: "function",
        name: "getTotalSupplyChainStages",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: "uint256" }]
      },
      {
        type: "function",
        name: "grantRole",
        stateMutability: "nonpayable",
        inputs: [
          { name: "role", type: "bytes32" },
          { name: "account", type: "address" }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "revokeRole",
        stateMutability: "nonpayable",
        inputs: [
          { name: "role", type: "bytes32" },
          { name: "account", type: "address" }
        ],
        outputs: []
      },
      {
        type: "event",
        name: "SensorDataSubmitted",
        inputs: [
          { indexed: true, name: "readingId", type: "uint256" },
          { indexed: true, name: "deviceId", type: "address" },
          { indexed: true, name: "farmId", type: "uint256" },
          { indexed: false, name: "timestamp", type: "uint256" }
        ]
      },
      {
        type: "event",
        name: "CropEventRecorded",
        inputs: [
          { indexed: true, name: "eventId", type: "uint256" },
          { indexed: true, name: "farmId", type: "uint256" },
          { indexed: false, name: "eventType", type: "string" },
          { indexed: false, name: "timestamp", type: "uint256" }
        ]
      }
    ];

    // Role hashes
    const ROLES = {
      DEVICE_ROLE: keccak256(toHex("DEVICE_ROLE")),
      FARMER_ROLE: keccak256(toHex("FARMER_ROLE")),
      RESEARCHER_ROLE: keccak256(toHex("RESEARCHER_ROLE")),
      SUPPLY_CHAIN_ROLE: keccak256(toHex("SUPPLY_CHAIN_ROLE"))
    };

    // ===== Network config
    const TEAM_CHAINS = {
      "00": { id: 252501, name: "DIDLab Main", rpc: "https://eth.didlab.org" }
    };

    // ===== UI elements
    const el = (id) => document.getElementById(id);
    const teamSel = el("team");
    const contractInput = el("contractAddr");
    const acctEl = el("acct");
    const netEl = el("net");
    const contractInfoEl = el("contractInfo");
    const totalReadingsEl = el("totalReadings");
    const totalEventsEl = el("totalEvents");
    const totalStagesEl = el("totalStages");
    const txlog = el("txlog");

    // ===== State
    let chain, contract;
    let walletClient, publicClient, account;

    // ===== Load/save prefs
    const saved = JSON.parse(localStorage.getItem("didlab-sensor-ui") || "{}");
    if (saved.team) teamSel.value = saved.team;
    if (saved.contract) contractInput.value = saved.contract;

    function save() {
      localStorage.setItem("didlab-sensor-ui", JSON.stringify({
        team: teamSel.value,
        contract: contractInput.value
      }));
    }

    // ===== Chain helpers
    function currentChain() {
      const t = TEAM_CHAINS[teamSel.value];
      return {
        id: t.id,
        name: t.name,
        nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
        rpcUrls: { default: { http: [t.rpc] } }
      };
    }

    function hexChainId(id) {
      return "0x" + id.toString(16);
    }

    async function ensureMetamask() {
      if (!window.ethereum) throw new Error("MetaMask not found");
    }

    async function addOrSwitchNetwork() {
      const t = TEAM_CHAINS[teamSel.value];
      const params = [{
        chainId: hexChainId(t.id),
        chainName: t.name,
        rpcUrls: [t.rpc],
        nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 }
      }];
      
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: params[0].chainId }]
        });
      } catch (e) {
        await window.ethereum.request({
          method: "wallet_addEthereumChain",
          params
        });
      }
    }

    async function connect() {
      await ensureMetamask();
      chain = currentChain();
      
      walletClient = createWalletClient({
        chain,
        transport: custom(window.ethereum)
      });
      publicClient = createPublicClient({
        chain,
        transport: custom(window.ethereum)
      });
      
      await addOrSwitchNetwork();
      const addrs = await window.ethereum.request({ method: "eth_requestAccounts" });
      account = getAddress(addrs[0]);
      
      acctEl.textContent = account;
      netEl.textContent = `${chain.name} (#${chain.id})`;
      logOk("Connected. Network ready.");
    }

    let sensorEventUnwatch = null;
    let cropEventUnwatch = null;

    async function loadContract() {
      contract = getAddress(contractInput.value.trim());
      save();
      contractInfoEl.textContent = contract;
      logOk(`Loaded contract ${contract}`);

      // Remove previous watchers
      if (sensorEventUnwatch) {
        sensorEventUnwatch();
        sensorEventUnwatch = null;
      }
      if (cropEventUnwatch) {
        cropEventUnwatch();
        cropEventUnwatch = null;
      }

      // Get current block number to avoid replaying old logs
      const latestBlock = await publicClient.getBlockNumber();

      // Track seen reading IDs to prevent duplicates
      const seenReadings = new Set();
      const seenEvents = new Set();

      // Watch SensorDataSubmitted events
      sensorEventUnwatch = publicClient.watchContractEvent({
        address: contract,
        abi: SENSOR_ABI,
        eventName: "SensorDataSubmitted",
        fromBlock: latestBlock + 1n,
        onLogs: (logs) => {
          for (const l of logs) {
            const id = l.args.readingId.toString();
            if (seenReadings.has(id)) continue;
            seenReadings.add(id);
            logOk(`ðŸ“Š New reading #${id} from device ${l.args.deviceId?.slice(0,8)}...`);
          }
          refresh();
        }
      });

      // Watch CropEventRecorded events
      cropEventUnwatch = publicClient.watchContractEvent({
        address: contract,
        abi: SENSOR_ABI,
        eventName: "CropEventRecorded",
        fromBlock: latestBlock + 1n,
        onLogs: (logs) => {
          for (const l of logs) {
            const id = l.args.eventId.toString();
            if (seenEvents.has(id)) continue;
            seenEvents.add(id);
            logOk(`ðŸŒ± Crop event #${id}: ${l.args.eventType}`);
          }
          refresh();
        }
      });

      await refresh();
    }

    async function refresh() {
      if (!contract) return;
      
      const totalReadings = await publicClient.readContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "getTotalReadings"
      });
      
      const totalEvents = await publicClient.readContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "getTotalCropEvents"
      });

      const totalStages = await publicClient.readContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "getTotalSupplyChainStages"
      });
      
      totalReadingsEl.textContent = totalReadings.toString();
      totalEventsEl.textContent = totalEvents.toString();
      totalStagesEl.textContent = totalStages.toString();
    }

    // ===== Submit sensor data
    async function submitReading() {
      const farmId = BigInt(el("farmId").value);
      const temp = parseFloat(el("temp").value);
      const moisture = parseFloat(el("moisture").value);
      const humidity = parseFloat(el("humidity").value);
      
      // Validate ranges
      if (moisture < 0 || moisture > 100) throw new Error("Soil moisture must be 0-100%");
      if (humidity < 0 || humidity > 100) throw new Error("Humidity must be 0-100%");
      
      // Convert to fixed-point (0.1 precision) and ensure proper integer types
      const tempInt = Math.round(temp * 10);
      const moistureInt = Math.round(moisture * 10);
      const humidityInt = Math.round(humidity * 10);
      
      console.log("Submitting:", { farmId, tempInt, moistureInt, humidityInt });
      
      const hash = await walletClient.writeContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "submitSensorData",
        args: [farmId, tempInt, moistureInt, humidityInt],
        account,
        gas: 300000n,
        gasPrice: 20000000000n
      });
      
      logWarn(`Submitted: ${hash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash });
      logOk(`âœ“ Reading recorded in block ${rcpt.blockNumber}`);
    }

    async function submitBatch() {
      const farms = el("batchFarms").value.split(",").map(s => BigInt(s.trim()));
      const temps = el("batchTemps").value.split(",").map(s => Math.round(parseFloat(s.trim()) * 10));
      const moistures = el("batchMoisture").value.split(",").map(s => Math.round(parseFloat(s.trim()) * 10));
      const humidities = el("batchHumidity").value.split(",").map(s => Math.round(parseFloat(s.trim()) * 10));
      
      if (farms.length !== temps.length || farms.length !== moistures.length || farms.length !== humidities.length) {
        throw new Error("Array lengths must match");
      }
      
      const hash = await walletClient.writeContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "submitBatch",
        args: [farms, temps, moistures, humidities],
        account,
        gas: 1000000n, // increased gas limit
      gasPrice: 50000000000n // increased gas price
      });
      
      logWarn(`Batch submitted: ${hash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash });
      logOk(`âœ“ Batch recorded in block ${rcpt.blockNumber} (${farms.length} readings)`);
    }

    // ===== Query readings
    async function queryReadings() {
      const farmId = BigInt(el("queryFarm").value);
      const indices = await publicClient.readContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "getReadingsByFarm",
        args: [farmId]
      });
      
      if (indices.length === 0) {
        el("readingsTable").innerHTML = "<p class='muted'>No readings found for this farm.</p>";
        return;
      }
      
      let html = "<table><thead><tr><th>#</th><th>Time</th><th>Device</th><th>Temp (Â°C)</th><th>Moisture (%)</th><th>Humidity (%)</th></tr></thead><tbody>";
      
      for (const idx of indices) {
        const reading = await publicClient.readContract({
          address: contract,
          abi: SENSOR_ABI,
          functionName: "readings",
          args: [idx]
        });
        
        const date = new Date(Number(reading[0]) * 1000).toLocaleString();
        const device = reading[1].slice(0, 10) + "...";
        const temp = (Number(reading[3]) / 10).toFixed(1);
        const moisture = (Number(reading[4]) / 10).toFixed(1);
        const humidity = (Number(reading[5]) / 10).toFixed(1);
        
        html += `<tr><td>${idx}</td><td>${date}</td><td class="mono">${device}</td><td>${temp}</td><td>${moisture}</td><td>${humidity}</td></tr>`;
      }
      
      html += "</tbody></table>";
      el("readingsTable").innerHTML = html;
    }

    // ===== Crop events
    async function recordCropEvent() {
      const farmId = BigInt(el("cropFarmId").value);
      const eventType = el("cropEventType").value;
      const notes = el("cropNotes").value;
      const hash = el("cropHash").value;
      
      const txHash = await walletClient.writeContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "recordCropEvent",
        args: [farmId, eventType, notes, hash],
        account,
        gas: 200000n,
        gasPrice: 20000000000n
      });
      
      logWarn(`Crop event submitted: ${txHash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash: txHash });
      logOk(`âœ“ Event recorded in block ${rcpt.blockNumber}`);
    }

    async function queryCropEvents() {
      const farmId = BigInt(el("queryCropFarm").value);
      const indices = await publicClient.readContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "getCropEventsByFarm",
        args: [farmId]
      });
      
      if (indices.length === 0) {
        el("cropEventsTable").innerHTML = "<p class='muted'>No crop events found for this farm.</p>";
        return;
      }
      
      let html = "<table><thead><tr><th>#</th><th>Time</th><th>Event Type</th><th>Notes</th></tr></thead><tbody>";
      
      for (const idx of indices) {
        const event = await publicClient.readContract({
          address: contract,
          abi: SENSOR_ABI,
          functionName: "cropEvents",
          args: [idx]
        });
        
        const date = new Date(Number(event[2]) * 1000).toLocaleString();
        html += `<tr><td>${idx}</td><td>${date}</td><td>${event[1]}</td><td>${event[3]}</td></tr>`;
      }
      
      html += "</tbody></table>";
      el("cropEventsTable").innerHTML = html;
    }

    // ===== Supply chain
    async function recordSupplyStage() {
      const productId = BigInt(el("productId").value);
      const stage = el("stage").value;
      const location = el("location").value;
      const hash = el("stageHash").value;
      
      const txHash = await walletClient.writeContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "recordSupplyChainStage",
        args: [productId, stage, location, hash],
        account,
        gas: 200000n,
        gasPrice: 20000000000n
      });
      
      logWarn(`Supply stage submitted: ${txHash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash: txHash });
      logOk(`âœ“ Stage recorded in block ${rcpt.blockNumber}`);
    }

    async function querySupplyChain() {
      const productId = BigInt(el("queryProduct").value);
      const indices = await publicClient.readContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "getSupplyChainStages",
        args: [productId]
      });
      
      if (indices.length === 0) {
        el("supplyTable").innerHTML = "<p class='muted'>No supply chain stages found for this product.</p>";
        return;
      }
      
      let html = "<table><thead><tr><th>#</th><th>Time</th><th>Stage</th><th>Location</th><th>Recorder</th></tr></thead><tbody>";
      
      for (const idx of indices) {
        const stage = await publicClient.readContract({
          address: contract,
          abi: SENSOR_ABI,
          functionName: "supplyChainStages",
          args: [idx]
        });
        
        const date = new Date(Number(stage[2]) * 1000).toLocaleString();
        const recorder = stage[3].slice(0, 10) + "...";
        html += `<tr><td>${idx}</td><td>${date}</td><td>${stage[1]}</td><td>${stage[4]}</td><td class="mono">${recorder}</td></tr>`;
      }
      
      html += "</tbody></table>";
      el("supplyTable").innerHTML = html;
    }

    // ===== Role management
    async function grantRole() {
      const role = ROLES[el("grantRole").value];
      const addr = getAddress(el("grantAddr").value.trim());
      
      const hash = await walletClient.writeContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "grantRole",
        args: [role, addr],
        account,
        gas: 100000n,
        gasPrice: 20000000000n
      });
      
      logWarn(`Grant role tx: ${hash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash });
      logOk(`âœ“ Role granted in block ${rcpt.blockNumber}`);
    }

    async function revokeRole() {
      const role = ROLES[el("revokeRole").value];
      const addr = getAddress(el("revokeAddr").value.trim());
      
      const hash = await walletClient.writeContract({
        address: contract,
        abi: SENSOR_ABI,
        functionName: "revokeRole",
        args: [role, addr],
        account,
        gas: 100000n,
        gasPrice: 20000000000n
      });
      
      logWarn(`Revoke role tx: ${hash}`);
      const rcpt = await publicClient.waitForTransactionReceipt({ hash });
      logOk(`âœ“ Role revoked in block ${rcpt.blockNumber}`);
    }

    // ===== Logging
    function logOk(m) {
      txlog.innerHTML = `<div class="ok">${escapeHtml(m)}</div>` + txlog.innerHTML;
    }
    
    function logWarn(m) {
      txlog.innerHTML = `<div class="warn">${escapeHtml(m)}</div>` + txlog.innerHTML;
    }
    
    function logErr(m) {
      txlog.innerHTML = `<div class="err">${escapeHtml(m)}</div>` + txlog.innerHTML;
    }
    
    function escapeHtml(s) {
      return String(s).replace(/[&<>"]/g, c => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;'
      }[c]));
    }

    // ===== Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active from all tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Add active to clicked tab
        tab.classList.add('active');
        const tabName = tab.getAttribute('data-tab');
        document.getElementById(`tab-${tabName}`).classList.add('active');
      });
    });

    // ===== Wire up buttons
    el("btnConnect").onclick = async () => {
      try {
        await connect();
      } catch (e) {
        logErr(e.message || e);
      }
    };

    el("btnLoad").onclick = async () => {
      try {
        await loadContract();
      } catch (e) {
        logErr(e.message || e);
      }
    };

    el("btnRefresh").onclick = async () => {
      try {
        await refresh();
      } catch (e) {
        logErr(e.message || e);
      }
    };

    el("btnSubmit").onclick = async () => {
      try {
        await submitReading();
      } catch (e) {
        logErr(e.shortMessage || e.message || e);
      }
    };

    el("btnBatch").onclick = async () => {
      try {
        await submitBatch();
      } catch (e) {
        logErr(e.shortMessage || e.message || e);
      }
    };

    el("btnQuery").onclick = async () => {
      try {
        await queryReadings();
      } catch (e) {
        logErr(e.message || e);
      }
    };

    el("btnCropEvent").onclick = async () => {
      try {
        await recordCropEvent();
      } catch (e) {
        logErr(e.shortMessage || e.message || e);
      }
    };

    el("btnQueryCrop").onclick = async () => {
      try {
        await queryCropEvents();
      } catch (e) {
        logErr(e.message || e);
      }
    };

    el("btnStage").onclick = async () => {
      try {
        await recordSupplyStage();
      } catch (e) {
        logErr(e.shortMessage || e.message || e);
      }
    };

    el("btnQuerySupply").onclick = async () => {
      try {
        await querySupplyChain();
      } catch (e) {
        logErr(e.message || e);
      }
    };

    el("btnGrant").onclick = async () => {
      try {
        await grantRole();
      } catch (e) {
        logErr(e.shortMessage || e.message || e);
      }
    };

    el("btnRevoke").onclick = async () => {
      try {
        await revokeRole();
      } catch (e) {
        logErr(e.shortMessage || e.message || e);
      }
    };
  </script>
</body>
</html>