<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SensorSeal - Cold Chain Monitoring</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #0b1320;
      color: #e6eaf2;
    }
    .wrap {
      max-width: 1400px;
      margin: 40px auto;
      padding: 24px;
      border: 1px solid #24314a;
      border-radius: 14px;
      background: #0f1a2b;
    }
    h1 {
      margin: 0 0 16px;
      font-size: 22px;
    }
    h3 {
      margin: 16px 0 8px;
      font-size: 16px;
    }
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 8px 0;
    }
    .row > * {
      flex: 1;
      min-width: 200px;
    }
    input, select, button, textarea {
      padding: 10px 12px;
      border: 1px solid #314164;
      background: #0b1527;
      color: #e6eaf2;
      border-radius: 10px;
      font-family: inherit;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
    }
    button {
      cursor: pointer;
    }
    button.primary {
      background: #335cff;
      border-color: #335cff;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px;
    }
    .card {
      padding: 16px;
      border: 1px solid #24314a;
      border-radius: 10px;
      background: #0b1527;
      margin: 12px 0;
    }
    .muted {
      opacity: .8;
    }
    .ok {
      color: #7be07b;
    }
    .warn {
      color: #ffd166;
    }
    .err {
      color: #ff6b6b;
    }
    a {
      color: #9bc1ff;
    }
    .kvs {
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 8px;
    }
    .kvs div {
      padding: 6px 8px;
      border-bottom: 1px dashed #22314e;
    }
    .tabs {
      display: flex;
      gap: 8px;
      margin: 16px 0;
      border-bottom: 2px solid #24314a;
    }
    .tab {
      padding: 10px 16px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #8a9bb8;
      border-radius: 10px 10px 0 0;
    }
    .tab.active {
      background: #0b1527;
      color: #e6eaf2;
      border-bottom: 2px solid #335cff;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 12px 0;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #24314a;
    }
    th {
      background: #0b1527;
      font-weight: 600;
    }
    .small {
      font-size: 13px;
    }
    label {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
      opacity: 0.8;
    }
    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
    }
    .badge-good {
      background: #1e4d2b;
      color: #7be07b;
    }
    .badge-breach {
      background: #5c1e1e;
      color: #ff6b6b;
    }
    .breach-card {
      border: 2px solid #ff6b6b;
      padding: 12px;
      margin: 8px 0;
      border-radius: 8px;
      background: #1a0f0f;
    }
    .verify-result {
      margin-top: 12px;
      padding: 12px;
      border-radius: 8px;
      border: 2px solid;
    }
    .verify-result.success {
      border-color: #7be07b;
      background: #1e4d2b;
    }
    .verify-result.error {
      border-color: #ff6b6b;
      background: #5c1e1e;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>‚ùÑÔ∏è SensorSeal - Cold Chain Monitoring</h1>
    
    <!-- CONFIG -->
    <div class="card">
      <div class="row">
        <div>
          <label>Network</label>
          <select id="team">
            <option value="didlab">DIDLab (252501)</option>
          </select>
        </div>
        <div>
          <label>Backend API URL</label>
          <input id="apiUrl" placeholder="http://localhost:3000" value="http://localhost:3000" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>DeviceRegistry Address</label>
          <input id="deviceRegistryAddr" class="mono" placeholder="0x..." />
        </div>
        <div>
          <label>DataAnchor Address</label>
          <input id="dataAnchorAddr" class="mono" placeholder="0x..." />
        </div>
        <div>
          <label>BreachNFT Address</label>
          <input id="breachNFTAddr" class="mono" placeholder="0x..." />
        </div>
      </div>
      <div class="row">
        <button id="btnConnect" class="primary">1) Connect Wallet & Switch Network</button>
        <button id="btnLoad">2) Load Contracts</button>
        <button id="btnRefresh">Refresh Stats</button>
      </div>
    </div>
    
    <!-- STATUS -->
    <div class="card">
      <div class="kvs">
        <div class="muted">Account</div>
        <div id="acct" class="mono">‚Äî</div>
        <div class="muted">Network</div>
        <div id="net" class="mono">‚Äî</div>
        <div class="muted">Backend Status</div>
        <div id="backendStatus">‚Äî</div>
        <div class="muted">Total Devices</div>
        <div id="totalDevices">‚Äî</div>
        <div class="muted">Total Batches</div>
        <div id="totalBatches">‚Äî</div>
        <div class="muted">Total Breaches</div>
        <div id="totalBreaches">‚Äî</div>
      </div>
    </div>

    <!-- TABS -->
    <div class="tabs">
      <button class="tab active" data-tab="devices">Devices</button>
      <button class="tab" data-tab="register">Register Device</button>
      <button class="tab" data-tab="batches">Batch History</button>
      <button class="tab" data-tab="breaches">Breaches</button>
      <button class="tab" data-tab="queue">Live Queue</button>
      <button class="tab" data-tab="device-chart">Device Chart</button>
      <button class="tab" data-tab="product-view">Product View</button>
    </div>

    <!-- TAB: DEVICES -->
    <div id="tab-devices" class="tab-content active">
      <div class="card">
        <h3>Registered Devices</h3>
        <div id="devicesTable"></div>
      </div>
    </div>

    <!-- TAB: REGISTER DEVICE -->
    <div id="tab-register" class="tab-content">
      <div class="card">
        <h3>Register New Device</h3>
        <p class="muted small">Register an IoT device with owner and product passport link</p>
        <div class="row">
          <div>
            <label>Device Address</label>
            <input id="regDeviceAddr" class="mono" placeholder="0x..." />
          </div>
          <div>
            <label>Owner Address</label>
            <input id="regOwner" class="mono" placeholder="0x..." />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Metadata CID (IPFS)</label>
            <input id="regMetadataCID" placeholder="QmPlaceholder..." value="QmPlaceholderMetadata123456789" />
          </div>
          <div>
            <label>Trace Token ID (Product Passport)</label>
            <input id="regTraceTokenId" type="number" placeholder="12345" value="12345" />
          </div>
        </div>
        <button id="btnRegister" class="primary">Register Device</button>
      </div>
    </div>

<!-- TAB: BATCH HISTORY -->
    <div id="tab-batches" class="tab-content">
      <div class="card">
        <h3>Batch History</h3>
        <div class="row">
          <button id="btnLoadBatches" class="primary" style="flex: 0 0 50%">Load Batches from Blockchain</button>
        </div>
        <div id="batchPagination" style="display: none; align-items: center; gap: 8px; margin-top: 8px;">
          <button id="btnBatchFirst">|&lt;&lt;</button>
          <button id="btnBatchPrev10">&lt;&lt;</button>
          <button id="btnBatchPrev">&lt;</button>
          <span id="batchPageInfo" class="small muted"></span>
          <button id="btnBatchNext">&gt;</button>
          <button id="btnBatchNext10">&gt;&gt;</button>
          <button id="btnBatchLast">&gt;&gt;|</button>
        </div>
        <div id="batchesTable"></div>
      </div>
      
      <div class="card">
        <h3>View & Verify Batch</h3>
        <p class="muted small">View on-chain batch data and optionally verify IPFS content</p>
        <div class="row">
          <div>
            <label>Batch ID</label>
            <input id="verifyBatchId" type="number" placeholder="1036" />
          </div>
          <button id="btnViewBatch" class="primary">üîç View Batch</button>
        </div>
        <div id="verifyResult"></div>
        
        <div id="verifyCIDSection" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 1px solid #24314a;">
          <h4>Verify IPFS Content</h4>
          <p class="muted small">Enter the IPFS CID to verify it matches the on-chain hash and view the data</p>
          <div class="row">
            <div style="flex: 3;">
              <label>IPFS CID</label>
              <input id="verifyCID" placeholder="QmYPdZ..." class="mono" />
            </div>
            <button id="btnVerifyCID" class="primary" style="flex: 0 0 auto;">‚úì Verify & Load Data</button>
          </div>
          <div id="cidVerifyResult"></div>
        </div>
      </div>
    </div>

    <!-- TAB: BREACHES -->
    <div id="tab-breaches" class="tab-content">
      <div class="card">
        <h3>Breach NFTs</h3>
        <button id="btnLoadBreaches">Load Recent Breaches</button>
        <div id="breachesTable"></div>
      </div>
      
      <div class="card">
        <h3>Check Product Breaches</h3>
        <div class="row">
          <div>
            <label>Trace Token ID</label>
            <input id="checkProductId" type="number" placeholder="12345" />
          </div>
          <button id="btnCheckProduct">Check Product</button>
        </div>
        <div id="productBreachResult"></div>
      </div>
    </div>

    <!-- TAB: LIVE QUEUE -->
    <div id="tab-queue" class="tab-content">
      <div class="card">
        <h3>Live Reading Queue</h3>
        <p class="muted small">Auto-refreshes every 5 seconds</p>
        <div id="queueStatus"></div>
      </div>
      
      <div class="card">
        <h3>Backend Health</h3>
        <div id="healthStatus"></div>
      </div>
    </div>
    <!-- TAB: DEVICE CHART -->
    <div id="tab-device-chart" class="tab-content">
      <div class="card">
        <h3>üìä Device Readings Chart</h3>
        <div class="row">
          <div>
            <label>Device Address</label>
            <input id="chartDeviceAddr" class="mono" placeholder="0x..." />
          </div>
          <button id="btnLoadChart" class="primary">Load Readings</button>
        </div>
        <div style="height: 400px; margin-top: 20px;">
          <canvas id="deviceChart"></canvas>
        </div>
        <div id="chartStats" class="small muted" style="margin-top: 12px;"></div>
        <div id="chartStats" class="small muted" style="margin-top: 12px;"></div>
        <div id="chartPagination" style="display: flex; gap: 8px; margin-top: 12px; align-items: center;">
          <button id="btnChartFirst">|&lt;&lt; Newest</button>
          <button id="btnChartPrev10">&lt;&lt; -10</button>
          <button id="btnChartPrev">‚Üê Newer</button>
          <span id="chartPageInfo" class="small muted"></span>
          <button id="btnChartNext">Older ‚Üí</button>
          <button id="btnChartNext10">+10 &gt;&gt;</button>
          <button id="btnChartLast">Oldest &gt;&gt;|</button>
        </div>
      </div>
    </div>

    <!-- TAB: PRODUCT VIEW -->
    <div id="tab-product-view" class="tab-content">
      <div class="card">
        <h3>üì¶ Product View (Trace Token)</h3>
        <div class="row">
          <div>
            <label>Trace Token ID</label>
            <input id="productViewId" type="number" placeholder="12345" />
          </div>
          <button id="btnLoadProduct" class="primary">Load Product</button>
        </div>
        <div id="productViewContent"></div>
      </div>
    </div>


    <!-- LOG -->
    <div class="card">
      <h3>Activity Log</h3>
      <div id="txlog" class="mono small"></div>
    </div>
  </div>

  <script type="module">
import {
  createPublicClient,
  createWalletClient,
  custom,
  getAddress,
  keccak256,
  toHex
} from "https://esm.sh/viem@2.37.5";

// ===== Contract ABIs (full, no placeholders)
const DEVICE_REGISTRY_ABI = [
  {
    type: 'function',
    name: 'addDevice',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'deviceAddress', type: 'address' },
      { name: 'owner', type: 'address' },
      { name: 'metadataCID', type: 'string' },
      { name: 'traceTokenId', type: 'uint256' }
    ],
    outputs: []
  },
  {
    type: 'function',
    name: 'getDevice',
    stateMutability: 'view',
    inputs: [{ name: 'deviceAddress', type: 'address' }],
    outputs: [{
      type: 'tuple',
      components: [
        { name: 'deviceAddress', type: 'address' },
        { name: 'owner', type: 'address' },
        { name: 'metadataCID', type: 'string' },
        { name: 'traceTokenId', type: 'uint256' },
        { name: 'registeredAt', type: 'uint256' },
        { name: 'active', type: 'bool' }
      ]
    }]
  },
  {
    type: 'function',
    name: 'getTotalDevices',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }]
  },
  {
    type: 'function',
    name: 'getDeviceByIndex',
    stateMutability: 'view',
    inputs: [{ name: 'index', type: 'uint256' }],
    outputs: [{ type: 'address' }]
  },
  {
    type: 'function',
    name: 'isDeviceActive',
    stateMutability: 'view',
    inputs: [{ name: 'deviceAddress', type: 'address' }],
    outputs: [{ type: 'bool' }]
  }
];

const DATA_ANCHOR_ABI = [
  {
    type: 'function',
    name: 'getBatch',
    stateMutability: 'view',
    inputs: [{ name: 'batchId', type: 'uint256' }],
    outputs: [{
      type: 'tuple',
      components: [
        { name: 'device', type: 'address' },
        { name: 'cidHash', type: 'bytes32' },
        { name: 'windowStart', type: 'uint64' },
        { name: 'windowEnd', type: 'uint64' },
        { name: 'timestamp', type: 'uint256' },
        { name: 'blockNumber', type: 'uint256' }
      ]
    }]
  },
  {
    type: 'function',
    name: 'getTotalBatches',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }]
  },
  {
    type: 'event',
    name: 'BatchCommitted',
    inputs: [
      { name: 'batchId', type: 'uint256', indexed: true },
      { name: 'device', type: 'address', indexed: true },
      { name: 'cidHash', type: 'bytes32', indexed: false },
      { name: 'windowStart', type: 'uint64', indexed: false },
      { name: 'windowEnd', type: 'uint64', indexed: false }
    ]
  }
];

const BREACH_NFT_ABI = [
  {
    type: 'function',
    name: 'getBreachInfo',
    stateMutability: 'view',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [{
      type: 'tuple',
      components: [
        { name: 'tokenId', type: 'uint256' },
        { name: 'device', type: 'address' },
        { name: 'traceTokenId', type: 'uint256' },
        { name: 'batchId', type: 'uint256' },
        { name: 'timestamp', type: 'uint256' },
        { name: 'breachType', type: 'string' },
        { name: 'metadataURI', type: 'string' }
      ]
    }]
  },
  {
    type: 'function',
    name: 'getTotalBreaches',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }]
  },
  {
    type: 'function',
    name: 'getBreachesByProduct',
    stateMutability: 'view',
    inputs: [{ name: 'traceTokenId', type: 'uint256' }],
    outputs: [{ type: 'uint256[]' }]
  },
  {
    type: 'function',
    name: 'getRecentBreaches',
    stateMutability: 'view',
    inputs: [{ name: 'count', type: 'uint256' }],
    outputs: [{ type: 'uint256[]' }]
  }
];

// ===== Network config
const CHAIN = {
  id: 252501,
  name: "DIDLab",
  rpc: "https://eth.didlab.org"
};

// ===== UI elements
const el = id => document.getElementById(id);
const apiUrlInput = el("apiUrl");
const deviceRegistryInput = el("deviceRegistryAddr");
const dataAnchorInput = el("dataAnchorAddr");
const breachNFTInput = el("breachNFTAddr");
const acctEl = el("acct");
const netEl = el("net");
const backendStatusEl = el("backendStatus");
const totalDevicesEl = el("totalDevices");
const totalBatchesEl = el("totalBatches");
const totalBreachesEl = el("totalBreaches");
const txlog = el("txlog");
const READINGS_PER_PAGE = 50; // Adjust as needed
// ===== State
let chain, deviceRegistryAddr, dataAnchorAddr, breachNFTAddr, apiUrl;
let walletClient, publicClient, account;
let queueInterval;
let currentReadingsPage = 1;
let totalReadingsCount = 0;
let deviceBatchesForChart = [];

// ===== Load/save prefs
const saved = JSON.parse(localStorage.getItem("sensorseal-ui") || "{}");
if (saved.apiUrl) apiUrlInput.value = saved.apiUrl;
if (saved.deviceRegistry) deviceRegistryInput.value = saved.deviceRegistry;
if (saved.dataAnchor) dataAnchorInput.value = saved.dataAnchor;
if (saved.breachNFT) breachNFTInput.value = saved.breachNFT;

function save() {
  localStorage.setItem("sensorseal-ui", JSON.stringify({
    apiUrl: apiUrlInput.value,
    deviceRegistry: deviceRegistryInput.value,
    dataAnchor: dataAnchorInput.value,
    breachNFT: breachNFTInput.value
  }));
}

// ===== Small logging helpers (essential)
function log(msg, cls = "") {
  try {
    const line = document.createElement("div");
    if (cls) line.classList.add(cls);
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    txlog.prepend(line);
  } catch (e) {
    // fallback console
    console.log(msg);
  }
}
const logOk = (m) => log(m, "ok");
const logWarn = (m) => log(m, "warn");
const logErr = (m) => log(m, "err");

// ===== Chain helpers
function hexChainId(id) {
  return "0x" + id.toString(16);
}

async function ensureMetamask() {
  if (!window.ethereum) throw new Error("MetaMask not found");
}

async function addOrSwitchNetwork() {
  const params = [{
    chainId: hexChainId(CHAIN.id),
    chainName: CHAIN.name,
    rpcUrls: [CHAIN.rpc],
    nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 }
  }];
  
  try {
    await window.ethereum.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: params[0].chainId }]
    });
  } catch (e) {
    await window.ethereum.request({
      method: "wallet_addEthereumChain",
      params
    });
  }
}

async function connect() {
  try {
    await ensureMetamask();
    chain = {
      id: CHAIN.id,
      name: CHAIN.name,
      nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
      rpcUrls: { default: { http: [CHAIN.rpc] } }
    };
    
    walletClient = createWalletClient({
      chain,
      transport: custom(window.ethereum)
    });
    publicClient = createPublicClient({
      chain,
      transport: custom(window.ethereum)
    });
    
    await addOrSwitchNetwork();
    const addrs = await window.ethereum.request({ method: "eth_requestAccounts" });
    account = getAddress(addrs[0]);
    
    acctEl.textContent = account;
    netEl.textContent = `${chain.name} (#${chain.id})`;
    logOk("‚úì Connected to wallet");
  } catch (e) {
    logErr("Wallet connect error: " + (e.message || e));
  }
}

async function loadContracts() {
  try {
    deviceRegistryAddr = getAddress(deviceRegistryInput.value.trim());
    dataAnchorAddr = getAddress(dataAnchorInput.value.trim());
    breachNFTAddr = getAddress(breachNFTInput.value.trim());
    apiUrl = apiUrlInput.value.trim();
    save();
    
    logOk(`‚úì Loaded contracts`);
    await checkBackend();
    await refresh();
    await loadDevices();
  } catch (e) {
    logErr("Load contracts error: " + (e.message || e));
  }
}

async function checkBackend() {
  try {
    const res = await fetch(`${apiUrl}/health`);
    const data = await res.json();
    backendStatusEl.innerHTML = `<span class="ok">‚úì Online</span> (${data.queuedReadings} queued, ${data.batchesCommitted} batches)`;
  } catch (e) {
    backendStatusEl.innerHTML = `<span class="err">‚úó Offline</span>`;
  }
}

async function refresh() {
  if (!deviceRegistryAddr || !dataAnchorAddr || !breachNFTAddr) return;
  
  try {
    const totalDevices = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getTotalDevices"
    });
    totalDevicesEl.textContent = totalDevices.toString();
    
    const totalBatches = await publicClient.readContract({
      address: dataAnchorAddr,
      abi: DATA_ANCHOR_ABI,
      functionName: "getTotalBatches"
    });
    totalBatchesEl.textContent = totalBatches.toString();
    
    const totalBreaches = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getTotalBreaches"
    });
    totalBreachesEl.textContent = totalBreaches.toString();
    
    await checkBackend();
  } catch (e) {
    logErr("Refresh error: " + (e.message || e));
  }
}

// ===== Device functions
async function loadDevices() {
  try {
    const total = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getTotalDevices"
    });
    
    if (total === 0n) {
      el("devicesTable").innerHTML = "<p class='muted'>No devices registered yet.</p>";
      return;
    }
    
    let html = "<table><thead><tr><th>Device</th><th>Owner</th><th>Trace Token ID</th><th>Status</th><th>Registered</th><th>Chart</th></tr></thead><tbody>";

    for (let i = 0; i < Number(total); i++) {
      const addr = await publicClient.readContract({
        address: deviceRegistryAddr,
        abi: DEVICE_REGISTRY_ABI,
        functionName: "getDeviceByIndex",
        args: [BigInt(i)]
      });
      
      const device = await publicClient.readContract({
        address: deviceRegistryAddr,
        abi: DEVICE_REGISTRY_ABI,
        functionName: "getDevice",
        args: [addr]
      });
      
      const status = device.active ? '<span class="ok">üü¢ Active</span>' : '<span class="err">üî¥ Inactive</span>';
      const date = new Date(Number(device.registeredAt) * 1000).toLocaleString();
      
      html += `<tr>
        <td class="mono">${String(addr).slice(0, 10)}...</td>
        <td class="mono">${String(device.owner).slice(0, 10)}...</td>
        <td>${device.traceTokenId.toString()}</td>
        <td>${status}</td>
        <td>${date}</td>
        <td><button class="small" onclick="document.getElementById('chartDeviceAddr').value='${addr}'; document.querySelector('[data-tab=device-chart]').click(); loadDeviceChart();">üìä</button></td>
      </tr>`;
    }
    
    html += "</tbody></table>";
    el("devicesTable").innerHTML = html;
  } catch (e) {
    logErr("Load devices error: " + (e.message || e));
  }
}

async function registerDevice() {
  try {
    const deviceAddr = getAddress(el("regDeviceAddr").value.trim());
    const owner = getAddress(el("regOwner").value.trim());
    const metadataCID = el("regMetadataCID").value.trim();
    const traceTokenId = BigInt(el("regTraceTokenId").value);
    
    const hash = await walletClient.writeContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "addDevice",
      args: [deviceAddr, owner, metadataCID, traceTokenId],
      account,
      gas: 500000n,
      gasPrice: 20000000000n
    });
    
    logWarn(`Device registration tx: ${hash}`);
    const rcpt = await publicClient.waitForTransactionReceipt({ hash });
    logOk(`‚úì Device registered in block ${rcpt.blockNumber}`);
    await loadDevices();
    await refresh();
  } catch (e) {
    logErr("Register device error: " + (e.message || e));
  }
}

// ===== Batch functions
// ===== Batch functions with pagination
const BATCHES_PER_PAGE = 20;
let currentBatchPage = 1;
let totalBatchCount = 0;

async function loadBatches() {
  try {
    const total = await publicClient.readContract({
      address: dataAnchorAddr,
      abi: DATA_ANCHOR_ABI,
      functionName: "getTotalBatches"
    });
    
    totalBatchCount = Number(total);
    
    if (totalBatchCount === 0) {
      el("batchesTable").innerHTML = "<p class='muted'>No batches committed yet.</p>";
      el("batchPagination").style.display = "none";
      return;
    }
    
    currentBatchPage = 1;
    el("batchPagination").style.display = "flex";
    await loadBatchPage(currentBatchPage);
  } catch (e) {
    logErr("Failed to load batches: " + (e.message || e));
  }
}

async function loadBatchPage(page) {
  try {
    const totalPages = Math.ceil(totalBatchCount / BATCHES_PER_PAGE);
    currentBatchPage = Math.max(1, Math.min(page, totalPages));
    
    // Calculate indices (newest first)
    const endIndex = totalBatchCount - (currentBatchPage - 1) * BATCHES_PER_PAGE;
    const startIndex = Math.max(0, endIndex - BATCHES_PER_PAGE);
    
    let html = "<table><thead><tr><th>Batch ID</th><th>Device</th><th>CID Hash</th><th>Window</th><th>Block</th></tr></thead><tbody>";
    
    // Load batches in reverse order (newest first)
    for (let i = endIndex - 1; i >= startIndex; i--) {
      const batch = await publicClient.readContract({
        address: dataAnchorAddr,
        abi: DATA_ANCHOR_ABI,
        functionName: "getBatch",
        args: [BigInt(i)]
      });
      
      const start = new Date(Number(batch.windowStart) * 1000).toLocaleTimeString();
      const end = new Date(Number(batch.windowEnd) * 1000).toLocaleTimeString();
      
      html += `<tr>
        <td>${i}</td>
        <td class="mono">${String(batch.device).slice(0, 10)}...</td>
        <td class="mono">${String(batch.cidHash).slice(0, 18)}...</td>
        <td class="small">${start} - ${end}</td>
        <td>${batch.blockNumber.toString()}</td>
      </tr>`;
    }
    
    html += "</tbody></table>";
    el("batchesTable").innerHTML = html;
    
    // Update pagination info
    el("batchPageInfo").textContent = `Page ${currentBatchPage} of ${totalPages} (${totalBatchCount} total)`;
    
    // Enable/disable buttons
    el("btnBatchFirst").disabled = currentBatchPage === 1;
    el("btnBatchPrev10").disabled = currentBatchPage === 1;
    el("btnBatchPrev").disabled = currentBatchPage === 1;
    el("btnBatchNext").disabled = currentBatchPage === totalPages;
    el("btnBatchNext10").disabled = currentBatchPage === totalPages;
    el("btnBatchLast").disabled = currentBatchPage === totalPages;
    
  } catch (e) {
    logErr("Failed to load batch page: " + (e.message || e));
  }
}

async function verifyBatch() {
  const batchIdRaw = el("verifyBatchId").value;
  if (!batchIdRaw) {
    el("verifyResult").innerHTML = `<div class="verify-result error">Please enter a batch id</div>`;
    return;
  }
  const batchId = BigInt(batchIdRaw);
  const resultDiv = el("verifyResult");
  resultDiv.innerHTML = "<p class='muted'>Loading batch from blockchain...</p>";
  
  try {
    // Get on-chain batch data
    const batch = await publicClient.readContract({
      address: dataAnchorAddr,
      abi: DATA_ANCHOR_ABI,
      functionName: "getBatch",
      args: [batchId]
    });
    
    const start = new Date(Number(batch.windowStart) * 1000).toLocaleString();
    const end = new Date(Number(batch.windowEnd) * 1000).toLocaleString();
    
    resultDiv.innerHTML = `
      <div class="verify-result success">
        <h4>üì¶ Batch #${batchId.toString()}</h4>
        <div class="kvs">
          <div class="muted">Device</div>
          <div class="mono">${batch.device}</div>
          
          <div class="muted">CID Hash (on-chain)</div>
          <div class="mono small">${batch.cidHash}</div>
          
          <div class="muted">Time Window</div>
          <div class="small">${start}<br>to ${end}</div>
          
          <div class="muted">Committed At</div>
          <div>${new Date(Number(batch.timestamp) * 1000).toLocaleString()}</div>
          
          <div class="muted">Block Number</div>
          <div>${batch.blockNumber.toString()}</div>
        </div>
      </div>
    `;
    
    // Show CID verification section
    el("verifyCIDSection").style.display = "block";
    
    // Store current batch for verification
    window.currentBatch = batch;
    window.currentBatchId = batchId;
    
  } catch (e) {
    resultDiv.innerHTML = `<div class="verify-result error">Error: ${e.message}</div>`;
    el("verifyCIDSection").style.display = "none";
  }
}

async function verifyCID() {
  const cid = el("verifyCID").value.trim();
  const resultDiv = el("cidVerifyResult");
  
  if (!cid) {
    resultDiv.innerHTML = `<div class="verify-result error">Please enter a CID</div>`;
    return;
  }
  
  if (!window.currentBatch) {
    resultDiv.innerHTML = `<div class="verify-result error">Please load a batch first</div>`;
    return;
  }
  
  resultDiv.innerHTML = "<p class='muted'>Verifying CID and fetching from IPFS...</p>";
  
  try {
    // Resolve device & pinned device CID from on-chain batch, then find batch CID in backend and verify
    const batchOnChain = window.currentBatch;
    const batchId = window.currentBatchId;
    const deviceAddress = String(batchOnChain.device);
    // Get device metadata CID from DeviceRegistry
    const deviceInfo = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getDevice",
      args: [deviceAddress]
    });
    const pinnedDeviceCID = String(deviceInfo.metadataCID).trim();

    // Fetch backend batch list and find the entry for this on-chain batch (match by blockNumber or txHash)
    const batchesRes = await fetch(`${apiUrl}/batches`);
    if (!batchesRes.ok) throw new Error('Failed to fetch backend batches');
    const batchesList = await batchesRes.json();
    const matched = batchesList.find(b =>
      String(b.blockNumber) === String(batchOnChain.blockNumber) ||
      String(b.txHash).toLowerCase() === (String(batchOnChain.txHash || '')).toLowerCase()
    );
    if (!matched) {
      resultDiv.innerHTML = `<div class="verify-result error"><h4>‚ö†Ô∏è Unable to locate batch CID in backend for this on-chain batch</h4></div>`;
      return;
    }
    const batchCid = String(matched.cid).trim();

    // Compute keccak256 over the batch CID's UTF-8 bytes (matches backend toHex(cid))
    const encoder = new TextEncoder();
    const bytes = encoder.encode(batchCid);
    const hex = '0x' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    const computedHash = keccak256(hex).toLowerCase();

    // Compare with on-chain value
    const onChainHash = String(batchOnChain.cidHash).toLowerCase();
    if (computedHash !== onChainHash) {
      resultDiv.innerHTML = `
        <div class="verify-result error">
          <h4>‚ö†Ô∏è HASH MISMATCH</h4>
          <p class="small">On-chain cidHash: <span class="mono">${onChainHash}</span></p>
          <p class="small">Computed from backend CID (${batchCid}): <span class="mono">${computedHash}</span></p>
        </div>
      `;
      return;
    }

    // At this point batchCid is verified against on-chain hash ‚Äî show the pinned device CID and proceed
    resultDiv.innerHTML = `
      <div class="verify-result success">
        <h4>‚úì Batch CID verified</h4>
        <div class="kvs">
          <div class="muted">Device (on-chain)</div><div class="mono">${deviceAddress}</div>
          <div class="muted">Pinned Device Metadata CID</div><div class="mono">${pinnedDeviceCID}</div>
          <div class="muted">Batch CID (backend)</div><div class="mono">${batchCid}</div>
        </div>
      </div>
    `;

    
    // Fetch from IPFS
    const ipfsRes = await fetch(`https://ipfs.io/ipfs/${cid}`);
    if (!ipfsRes.ok) {
      throw new Error(`IPFS fetch failed: ${ipfsRes.statusText}`);
    }
    
    const batchData = await ipfsRes.json();
    
    // Display verified data
    resultDiv.innerHTML = `
      <div class="verify-result success">
        <h4>‚úÖ VERIFIED - CID MATCHES ON-CHAIN HASH</h4>
        
        <p><strong>IPFS CID:</strong> <span class="mono">${cid}</span></p>
        <p><a href="https://ipfs.io/ipfs/${cid}" target="_blank">View on IPFS ‚Üí</a></p>
        
        <div style="margin-top: 12px;">
          <strong>Batch Contents:</strong>
          <div class="kvs" style="margin-top: 8px;">
            <div class="muted">Device</div>
            <div class="mono">${batchData.device}</div>
            
            <div class="muted">Readings Count</div>
            <div>${batchData.count || batchData.readings?.length || 0}</div>
            
            <div class="muted">Window</div>
            <div class="small">
              ${
                batchData.window
                  ? `${new Date(batchData.window.start * 1000).toLocaleString()}<br>to ${new Date(batchData.window.end * 1000).toLocaleString()}`
                  : "Not available in IPFS data"
              }
            </div>

          </div>
        </div>
        
        ${batchData.readings ? `
          <details style="margin-top: 12px;">
            <summary style="cursor: pointer; font-weight: 600;">üìä View Readings (${batchData.readings.length})</summary>
            <div style="max-height: 300px; overflow-y: auto; margin-top: 8px;">
              <table class="small">
                <thead>
                  <tr>
                    <th>Time</th>
                    <th>Temp (¬∞C)</th>
                    <th>Humidity (%)</th>
                  </tr>
                </thead>
                <tbody>
                  ${batchData.readings.slice(0, 50).map(r => `
                    <tr>
                      <td>${new Date(r.t * 1000).toLocaleTimeString()}</td>
                      <td>${r.temp}</td>
                      <td>${r.hum}</td>
                    </tr>
                  `).join('')}
                  ${batchData.readings.length > 50 ? `
                    <tr><td colspan="3" class="muted">... and ${batchData.readings.length - 50} more</td></tr>
                  ` : ''}
                </tbody>
              </table>
            </div>
          </details>
        ` : ''}
      </div>
    `;
    
    logOk(`‚úì Batch verified and loaded from IPFS`);
    
  } catch (e) {
    resultDiv.innerHTML = `
      <div class="verify-result error">
        <h4>Error Loading from IPFS</h4>
        <p>${e.message}</p>
        <p class="small muted">The hash may match, but the content could not be retrieved from IPFS.</p>
      </div>
    `;
    logErr("IPFS fetch error: " + e.message);
  }
}

// ===== Breach functions
async function loadBreaches() {
  try {
    const tokenIds = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getRecentBreaches",
      args: [10n]
    });
    
    if (!tokenIds || tokenIds.length === 0) {
      el("breachesTable").innerHTML = "<p class='muted'>No breaches detected yet. üéâ</p>";
      return;
    }
    
    let html = "";
    
    for (const tokenId of tokenIds) {
      const breach = await publicClient.readContract({
        address: breachNFTAddr,
        abi: BREACH_NFT_ABI,
        functionName: "getBreachInfo",
        args: [tokenId]
      });
      
      const date = new Date(Number(breach.timestamp) * 1000).toLocaleString();
      const ipfsLink = String(breach.metadataURI).replace("ipfs://", "");
      
      html += `
        <div class="breach-card">
          <h4>üî¥ Breach NFT #${tokenId.toString()}</h4>
          <div class="kvs">
            <div class="muted">Device</div><div class="mono">${breach.device}</div>
            <div class="muted">Product (traceToken)</div><div>${breach.traceTokenId.toString()}</div>
            <div class="muted">Batch</div><div>${breach.batchId.toString()}</div>
            <div class="muted">When</div><div>${date}</div>
            <div class="muted">Type</div><div>${breach.breachType}</div>
            <div class="muted">Report</div><div><a href="https://ipfs.io/ipfs/${ipfsLink}" target="_blank">${ipfsLink.slice(0,18)}...</a></div>
          </div>
        </div>
      `;
    }
    
    el("breachesTable").innerHTML = html;
  } catch (e) {
    logErr("Failed to load breaches: " + (e.message || e));
  }
}

async function checkProduct() {
  try {
    const traceIdRaw = el("checkProductId").value;
    if (!traceIdRaw) {
      el("productBreachResult").innerHTML = "<p class='muted'>Enter a product trace token id</p>";
      return;
    }
    const traceId = BigInt(traceIdRaw);
    
    const breachIds = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getBreachesByProduct",
      args: [traceId]
    });
    
    if (!breachIds || breachIds.length === 0) {
      el("productBreachResult").innerHTML = `<div class="verify-result success">No breaches for product ${traceId.toString()}</div>`;
      return;
    }
    
    const list = Array.from(breachIds).map(id => `#${id.toString()}`).join(", ");
    el("productBreachResult").innerHTML = `<div class="verify-result error">Breaches found: ${list}</div>`;
  } catch (e) {
    el("productBreachResult").innerHTML = `<div class="verify-result error">Error: ${e.message}</div>`;
  }
}

// ===== Minimal queue/health loader (essential)
async function loadQueue() {
  if (!apiUrl) return;
  try {
    const res = await fetch(`${apiUrl}/health`);
    const d = await res.json();
    el("queueStatus").innerHTML = `<p class="small">Queued: ${d.queuedReadings} ¬∑ Batches: ${d.batchesCommitted}</p>`;
    el("healthStatus").innerHTML = `<p class="small">Backend last checked: ${new Date().toLocaleTimeString()}</p>`;
  } catch (e) {
    el("queueStatus").innerHTML = `<p class="err">Backend offline</p>`;
    el("healthStatus").innerHTML = `<p class="err">Backend offline</p>`;
  }
}

// ===== Tab navigation (essential)
document.querySelectorAll(".tab").forEach(tab => {
  tab.addEventListener("click", () => {
    document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    tab.classList.add("active");
    const name = tab.dataset.tab;
    const target = document.getElementById("tab-" + name);
    if (target) target.classList.add("active");
  });
});

// ===== Chart functions
let deviceChartInstance = null;

async function loadDeviceChart() {
  try {
    const deviceAddr = getAddress(el("chartDeviceAddr").value.trim());
    
    // Fetch batch metadata only
    const res = await fetch(`${apiUrl}/batches`);
    const batches = await res.json();
    
    deviceBatchesForChart = batches.filter(b => 
      b.device.toLowerCase() === deviceAddr.toLowerCase()
    ).sort((a, b) => b.timestamp - a.timestamp); // Newest first
    
    if (deviceBatchesForChart.length === 0) {
      el("chartStats").innerHTML = "No data found for this device";
      return;
    }
    
    // Count total readings without fetching IPFS
    totalReadingsCount = deviceBatchesForChart.length * 10; // Estimate, will refine
    currentReadingsPage = 1;
    
    await loadChartPage(1);
    
  } catch (e) {
    logErr("Chart load error: " + (e.message || e));
  }
}

async function loadChartPage(page) {
  try {
    // Calculate which batches we need
    const skip = (page - 1) * READINGS_PER_PAGE;
    let readingsNeeded = READINGS_PER_PAGE;
    let readingsSkipped = 0;
    let batchIdx = 0;
    
    // Figure out which batches to fetch
    const batchesToFetch = [];
    while (readingsNeeded > 0 && batchIdx < deviceBatchesForChart.length) {
      batchesToFetch.push(deviceBatchesForChart[batchIdx]);
      batchIdx++;
      // Assume ~10 readings per batch for estimation
      if (readingsSkipped < skip) {
        readingsSkipped += 10;
      } else {
        readingsNeeded -= 10;
      }
    }
    
    // Fetch all needed batches in parallel
    const batchPromises = batchesToFetch.map(batch =>
      fetch(`https://ipfs.io/ipfs/${batch.cid}`)
        .then(r => r.json())
        .catch(() => null)
    );
    const batchResults = await Promise.all(batchPromises);
    
    // Collect readings
    let readings = [];
    readingsSkipped = 0;
    const skipTarget = (page - 1) * READINGS_PER_PAGE;
    
    for (const batchData of batchResults) {
      if (!batchData || !batchData.readings) continue;
      
      if (readingsSkipped < skipTarget) {
        const toSkip = Math.min(batchData.readings.length, skipTarget - readingsSkipped);
        readingsSkipped += toSkip;
        
        if (readingsSkipped >= skipTarget) {
          readings = readings.concat(batchData.readings.slice(toSkip));
        }
      } else {
        readings = readings.concat(batchData.readings);
      }
      
      if (readings.length >= READINGS_PER_PAGE) break;
    }
    
    // Trim to page size
    readings = readings.slice(0, READINGS_PER_PAGE);
    
    if (readings.length === 0) {
      el("chartStats").innerHTML = "No readings found";
      return;
    }
    
    // Sort chronologically for display
    readings.sort((a, b) => a.t - b.t);
    
    // Render chart
    const labels = readings.map(r => new Date(r.t * 1000).toLocaleTimeString());
    const temps = readings.map(r => r.temp);
    const hums = readings.map(r => r.hum);
    
    if (deviceChartInstance) {
      deviceChartInstance.destroy();
    }
    
    const ctx = el("deviceChart").getContext("2d");
    deviceChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Temperature (¬∞C)',
            data: temps,
            borderColor: '#ff6b6b',
            backgroundColor: 'rgba(255, 107, 107, 0.1)',
            yAxisID: 'y',
            tension: 0.4
          },
          {
            label: 'Humidity (%)',
            data: hums,
            borderColor: '#4ecdc4',
            backgroundColor: 'rgba(78, 205, 196, 0.1)',
            yAxisID: 'y1',
            tension: 0.4
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        plugins: {
          legend: {
            labels: { color: '#e6eaf2' }
          }
        },
        scales: {
          x: {
            ticks: { color: '#8a9bb8' },
            grid: { color: '#24314a' }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: { display: true, text: 'Temperature (¬∞C)', color: '#e6eaf2' },
            ticks: { color: '#ff6b6b' },
            grid: { color: '#24314a' }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            title: { display: true, text: 'Humidity (%)', color: '#e6eaf2' },
            ticks: { color: '#4ecdc4' },
            grid: { drawOnChartArea: false }
          }
        }
      }
    });
    
    // Stats
    const avgTemp = (temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1);
    const minTemp = Math.min(...temps).toFixed(1);
    const maxTemp = Math.max(...temps).toFixed(1);
    const breaches = temps.filter(t => t < 2 || t > 8).length;
    
    const totalPages = Math.ceil(totalReadingsCount / READINGS_PER_PAGE);
    el("chartStats").innerHTML = `
      ${readings.length} readings | 
      Avg: ${avgTemp}¬∞C | 
      Range: ${minTemp}¬∞C - ${maxTemp}¬∞C | 
      Breaches: ${breaches}
`     ;
el("chartPageInfo").textContent = `Page ${page} of ~${totalPages}`;
    
    currentReadingsPage = page;
    
    logOk(`Loaded chart page ${page}`);
  } catch (e) {
    logErr("Chart page error: " + (e.message || e));
  }
}

async function loadProductView() {
  try {
    const traceId = BigInt(el("productViewId").value);
    const contentDiv = el("productViewContent");
    contentDiv.innerHTML = "<p class='muted'>Loading...</p>";
    
    // Get devices for this product
    const devices = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getDevicesByProduct",
      args: [traceId]
    });
    
    if (!devices || devices.length === 0) {
      contentDiv.innerHTML = "<p class='muted'>No devices monitoring this product</p>";
      return;
    }
    
    // Get breaches for this product
    const breachIds = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getBreachesByProduct",
      args: [traceId]
    });
    
    let html = `<h4>Product Trace Token #${traceId.toString()}</h4>`;
    
    // Status badge
    if (!breachIds || breachIds.length === 0) {
      html += `<div class="badge badge-good">‚úì NO BREACHES DETECTED</div>`;
    } else {
      html += `<div class="badge badge-breach">‚ö† ${breachIds.length} BREACH(ES) DETECTED</div>`;
    }
    
    html += "<h4 style='margin-top: 20px;'>Monitoring Devices</h4>";
    html += "<table><thead><tr><th>Device</th><th>Owner</th><th>Status</th><th>Actions</th></tr></thead><tbody>";
    
    for (const deviceAddr of devices) {
      const device = await publicClient.readContract({
        address: deviceRegistryAddr,
        abi: DEVICE_REGISTRY_ABI,
        functionName: "getDevice",
        args: [deviceAddr]
      });
      
      const status = device.active ? '<span class="ok">üü¢ Active</span>' : '<span class="err">üî¥ Inactive</span>';
      
      html += `<tr>
        <td class="mono">${String(deviceAddr).slice(0, 16)}...</td>
        <td class="mono">${String(device.owner).slice(0, 16)}...</td>
        <td>${status}</td>
        <td><button class="small" onclick="document.getElementById('chartDeviceAddr').value='${deviceAddr}'; document.querySelector('[data-tab=device-chart]').click(); loadDeviceChart();">View Chart</button></td>
      </tr>`;
    }
    
    html += "</tbody></table>";
    
    // Show breaches if any
    if (breachIds && breachIds.length > 0) {
      html += "<h4 style='margin-top: 20px;'>Breach History</h4>";
      
      for (const tokenId of breachIds) {
        const breach = await publicClient.readContract({
          address: breachNFTAddr,
          abi: BREACH_NFT_ABI,
          functionName: "getBreachInfo",
          args: [tokenId]
        });
        
        const date = new Date(Number(breach.timestamp) * 1000).toLocaleString();
        const ipfsLink = String(breach.metadataURI).replace("ipfs://", "");
        
        html += `
          <div class="breach-card" style="margin-top: 8px;">
            <strong>Breach NFT #${tokenId.toString()}</strong> - ${breach.breachType}<br>
            <span class="small">Device: ${String(breach.device).slice(0, 16)}... | ${date}</span><br>
            <a href="https://ipfs.io/ipfs/${ipfsLink}" target="_blank">View Report ‚Üí</a>
          </div>
        `;
      }
    }
    
    contentDiv.innerHTML = html;
    logOk(`Loaded product view for trace token ${traceId.toString()}`);
  } catch (e) {
    logErr("Product view error: " + (e.message || e));
    el("productViewContent").innerHTML = `<p class="err">Error: ${e.message}</p>`;
  }
}

// Add missing ABI function for getDevicesByProduct
DEVICE_REGISTRY_ABI.push({
  type: 'function',
  name: 'getDevicesByProduct',
  stateMutability: 'view',
  inputs: [{ name: 'traceTokenId', type: 'uint256' }],
  outputs: [{ type: 'address[]' }]
});

// ===== Button wiring (essential)
el("btnConnect").addEventListener("click", connect);
el("btnLoad").addEventListener("click", loadContracts);
el("btnRefresh").addEventListener("click", refresh);
el("btnRegister").addEventListener("click", registerDevice);
el("btnLoadBatches").addEventListener("click", loadBatches);
el("btnBatchFirst").addEventListener("click", () => loadBatchPage(1));
el("btnBatchPrev10").addEventListener("click", () => loadBatchPage(currentBatchPage - 10));
el("btnBatchPrev").addEventListener("click", () => loadBatchPage(currentBatchPage - 1));
el("btnBatchNext").addEventListener("click", () => loadBatchPage(currentBatchPage + 1));
el("btnBatchNext10").addEventListener("click", () => loadBatchPage(currentBatchPage + 10));
el("btnBatchLast").addEventListener("click", () => loadBatchPage(Math.ceil(totalBatchCount / BATCHES_PER_PAGE)));
el("btnViewBatch").addEventListener("click", verifyBatch);
el("btnVerifyCID").addEventListener("click", verifyCID);
el("btnLoadBreaches").addEventListener("click", loadBreaches);
el("btnCheckProduct").addEventListener("click", checkProduct);
el("btnLoadChart").addEventListener("click", loadDeviceChart);
el("btnChartPrev").addEventListener("click", () => {
  if (currentReadingsPage > 1) {
    loadChartPage(currentReadingsPage - 1);
  }
});
el("btnChartNext").addEventListener("click", () => {
  loadChartPage(currentReadingsPage + 1);
});
el("btnLoadProduct").addEventListener("click", loadProductView);
el("btnLoadProduct").addEventListener("click", loadProductView);
el("btnChartFirst").addEventListener("click", () => loadChartPage(1));
el("btnChartPrev10").addEventListener("click", () => loadChartPage(Math.max(1, currentReadingsPage - 10)));
el("btnChartNext10").addEventListener("click", () => loadChartPage(currentReadingsPage + 10));
el("btnChartLast").addEventListener("click", () => {
  const totalPages = Math.ceil(totalReadingsCount / READINGS_PER_PAGE);
  loadChartPage(totalPages);
});

// Start minimal periodic queue loader (bare minimum, 5s)
queueInterval = setInterval(() => {
  try { loadQueue(); } catch (e) { /* noop */ }
}, 5000);

// End of script
</script>