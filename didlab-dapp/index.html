<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SensorSeal - Cold Chain Monitoring</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #0b1320;
      color: #e6eaf2;
    }
    .wrap {
      max-width: 1400px;
      margin: 40px auto;
      padding: 24px;
      border: 1px solid #24314a;
      border-radius: 14px;
      background: #0f1a2b;
    }
    h1 {
      margin: 0 0 16px;
      font-size: 22px;
    }
    h3 {
      margin: 16px 0 8px;
      font-size: 16px;
    }
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 8px 0;
    }
    .row > * {
      flex: 1;
      min-width: 200px;
    }
    input, select, button, textarea {
      padding: 10px 12px;
      border: 1px solid #314164;
      background: #0b1527;
      color: #e6eaf2;
      border-radius: 10px;
      font-family: inherit;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
    }
    button {
      cursor: pointer;
    }
    button.primary {
      background: #335cff;
      border-color: #335cff;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px;
    }
    .card {
      padding: 16px;
      border: 1px solid #24314a;
      border-radius: 10px;
      background: #0b1527;
      margin: 12px 0;
    }
    .muted {
      opacity: .8;
    }
    .ok {
      color: #7be07b;
    }
    .warn {
      color: #ffd166;
    }
    .err {
      color: #ff6b6b;
    }
    a {
      color: #9bc1ff;
    }
    .kvs {
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 8px;
    }
    .kvs div {
      padding: 6px 8px;
      border-bottom: 1px dashed #22314e;
    }
    .tabs {
      display: flex;
      gap: 8px;
      margin: 16px 0;
      border-bottom: 2px solid #24314a;
    }
    .tab {
      padding: 10px 16px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #8a9bb8;
      border-radius: 10px 10px 0 0;
    }
    .tab.active {
      background: #0b1527;
      color: #e6eaf2;
      border-bottom: 2px solid #335cff;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 12px 0;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #24314a;
    }
    th {
      background: #0b1527;
      font-weight: 600;
    }
    .small {
      font-size: 13px;
    }
    label {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
      opacity: 0.8;
    }
    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
    }
    .badge-good {
      background: #1e4d2b;
      color: #7be07b;
    }
    .badge-breach {
      background: #5c1e1e;
      color: #ff6b6b;
    }
    .breach-card {
      border: 2px solid #ff6b6b;
      padding: 12px;
      margin: 8px 0;
      border-radius: 8px;
      background: #1a0f0f;
    }
    .verify-result {
      margin-top: 12px;
      padding: 12px;
      border-radius: 8px;
      border: 2px solid;
    }
    .verify-result.success {
      border-color: #7be07b;
      background: #1e4d2b;
    }
    .verify-result.error {
      border-color: #ff6b6b;
      background: #5c1e1e;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>‚ùÑÔ∏è SensorSeal - Cold Chain Monitoring</h1>
    
    <!-- CONFIG -->
    <div class="card">
      <div class="row">
        <div>
          <label>Network</label>
          <select id="team">
            <option value="didlab">DIDLab (252501)</option>
          </select>
        </div>
        <div>
          <label>Backend API URL</label>
          <input id="apiUrl" placeholder="http://localhost:3000" value="http://localhost:3000" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>DeviceRegistry Address</label>
          <input id="deviceRegistryAddr" class="mono" placeholder="0x..." />
        </div>
        <div>
          <label>DataAnchor Address</label>
          <input id="dataAnchorAddr" class="mono" placeholder="0x..." />
        </div>
        <div>
          <label>BreachNFT Address</label>
          <input id="breachNFTAddr" class="mono" placeholder="0x..." />
        </div>
      </div>
      <div class="row">
        <button id="btnConnect" class="primary">1) Connect Wallet & Switch Network</button>
        <button id="btnLoad">2) Load Contracts</button>
        <button id="btnRefresh">Refresh Stats</button>
      </div>
    </div>
    
    <!-- STATUS -->
    <div class="card">
      <div class="kvs">
        <div class="muted">Account</div>
        <div id="acct" class="mono">‚Äî</div>
        <div class="muted">Network</div>
        <div id="net" class="mono">‚Äî</div>
        <div class="muted">Backend Status</div>
        <div id="backendStatus">‚Äî</div>
        <div class="muted">Total Devices</div>
        <div id="totalDevices">‚Äî</div>
        <div class="muted">Total Batches</div>
        <div id="totalBatches">‚Äî</div>
        <div class="muted">Total Breaches</div>
        <div id="totalBreaches">‚Äî</div>
      </div>
    </div>

    <!-- TABS -->
    <div class="tabs">
      <button class="tab active" data-tab="devices">Devices</button>
      <button class="tab" data-tab="register">Register Device</button>
      <button class="tab" data-tab="batches">Batch History</button>
      <button class="tab" data-tab="breaches">Breaches</button>
      <button class="tab" data-tab="queue">Live Queue</button>
      <button class="tab" data-tab="device-chart">Device Chart</button>
      <button class="tab" data-tab="product-view">Product View</button>
    </div>

    <!-- TAB: DEVICES -->
    <div id="tab-devices" class="tab-content active">
      <div class="card">
        <h3>Registered Devices</h3>
        <div id="devicesTable"></div>
      </div>
    </div>

    <!-- TAB: REGISTER DEVICE -->
    <div id="tab-register" class="tab-content">
      <div class="card">
        <h3>Register New Device</h3>
        <p class="muted small">Register an IoT device with owner and product passport link</p>
        <div class="row">
          <div>
            <label>Device Address</label>
            <input id="regDeviceAddr" class="mono" placeholder="0x..." />
          </div>
          <div>
            <label>Owner Address</label>
            <input id="regOwner" class="mono" placeholder="0x..." />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Metadata CID (IPFS)</label>
            <input id="regMetadataCID" placeholder="QmPlaceholder..." value="QmPlaceholderMetadata123456789" />
          </div>
          <div>
            <label>Trace Token ID (Product Passport)</label>
            <input id="regTraceTokenId" type="number" placeholder="12345" value="12345" />
          </div>
        </div>
        <button id="btnRegister" class="primary">Register Device</button>
      </div>
    </div>

    <!-- TAB: BATCH HISTORY -->
    <div id="tab-batches" class="tab-content">
      <div class="card">
        <h3>Batch History</h3>
        <button id="btnLoadBatches">Load Batches from Backend</button>
        <div id="batchesTable"></div>
      </div>
      
      <div class="card">
        <h3>Verify Batch Integrity</h3>
        <div class="row">
          <div>
            <label>Batch ID</label>
            <input id="verifyBatchId" type="number" placeholder="0" />
          </div>
          <button id="btnVerify" class="primary">üîç Verify Hash</button>
        </div>
        <div id="verifyResult"></div>
      </div>
    </div>

    <!-- TAB: BREACHES -->
    <div id="tab-breaches" class="tab-content">
      <div class="card">
        <h3>Breach NFTs</h3>
        <button id="btnLoadBreaches">Load Recent Breaches</button>
        <div id="breachesTable"></div>
      </div>
      
      <div class="card">
        <h3>Check Product Breaches</h3>
        <div class="row">
          <div>
            <label>Trace Token ID</label>
            <input id="checkProductId" type="number" placeholder="12345" />
          </div>
          <button id="btnCheckProduct">Check Product</button>
        </div>
        <div id="productBreachResult"></div>
      </div>
    </div>

    <!-- TAB: LIVE QUEUE -->
    <div id="tab-queue" class="tab-content">
      <div class="card">
        <h3>Live Reading Queue</h3>
        <p class="muted small">Auto-refreshes every 5 seconds</p>
        <div id="queueStatus"></div>
      </div>
      
      <div class="card">
        <h3>Backend Health</h3>
        <div id="healthStatus"></div>
      </div>
    </div>
    <!-- TAB: DEVICE CHART -->
    <div id="tab-device-chart" class="tab-content">
      <div class="card">
        <h3>üìä Device Readings Chart</h3>
        <div class="row">
          <div>
            <label>Device Address</label>
            <input id="chartDeviceAddr" class="mono" placeholder="0x..." />
          </div>
          <button id="btnLoadChart" class="primary">Load Readings</button>
        </div>
        <div style="height: 400px; margin-top: 20px;">
          <canvas id="deviceChart"></canvas>
        </div>
        <div id="chartStats" class="small muted" style="margin-top: 12px;"></div>
      </div>
    </div>

    <!-- TAB: PRODUCT VIEW -->
    <div id="tab-product-view" class="tab-content">
      <div class="card">
        <h3>üì¶ Product View (Trace Token)</h3>
        <div class="row">
          <div>
            <label>Trace Token ID</label>
            <input id="productViewId" type="number" placeholder="12345" />
          </div>
          <button id="btnLoadProduct" class="primary">Load Product</button>
        </div>
        <div id="productViewContent"></div>
      </div>
    </div>

4. Add JavaS
    <!-- LOG -->
    <div class="card">
      <h3>Activity Log</h3>
      <div id="txlog" class="mono small"></div>
    </div>
  </div>

  <script type="module">
import {
  createPublicClient,
  createWalletClient,
  custom,
  getAddress,
  keccak256,
  toHex
} from "https://esm.sh/viem@2.37.5";

// ===== Contract ABIs (full, no placeholders)
const DEVICE_REGISTRY_ABI = [
  {
    type: 'function',
    name: 'addDevice',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'deviceAddress', type: 'address' },
      { name: 'owner', type: 'address' },
      { name: 'metadataCID', type: 'string' },
      { name: 'traceTokenId', type: 'uint256' }
    ],
    outputs: []
  },
  {
    type: 'function',
    name: 'getDevice',
    stateMutability: 'view',
    inputs: [{ name: 'deviceAddress', type: 'address' }],
    outputs: [{
      type: 'tuple',
      components: [
        { name: 'deviceAddress', type: 'address' },
        { name: 'owner', type: 'address' },
        { name: 'metadataCID', type: 'string' },
        { name: 'traceTokenId', type: 'uint256' },
        { name: 'registeredAt', type: 'uint256' },
        { name: 'active', type: 'bool' }
      ]
    }]
  },
  {
    type: 'function',
    name: 'getTotalDevices',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }]
  },
  {
    type: 'function',
    name: 'getDeviceByIndex',
    stateMutability: 'view',
    inputs: [{ name: 'index', type: 'uint256' }],
    outputs: [{ type: 'address' }]
  },
  {
    type: 'function',
    name: 'isDeviceActive',
    stateMutability: 'view',
    inputs: [{ name: 'deviceAddress', type: 'address' }],
    outputs: [{ type: 'bool' }]
  }
];

const DATA_ANCHOR_ABI = [
  {
    type: 'function',
    name: 'getBatch',
    stateMutability: 'view',
    inputs: [{ name: 'batchId', type: 'uint256' }],
    outputs: [{
      type: 'tuple',
      components: [
        { name: 'device', type: 'address' },
        { name: 'cidHash', type: 'bytes32' },
        { name: 'windowStart', type: 'uint64' },
        { name: 'windowEnd', type: 'uint64' },
        { name: 'timestamp', type: 'uint256' },
        { name: 'blockNumber', type: 'uint256' }
      ]
    }]
  },
  {
    type: 'function',
    name: 'getTotalBatches',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }]
  }
];

const BREACH_NFT_ABI = [
  {
    type: 'function',
    name: 'getBreachInfo',
    stateMutability: 'view',
    inputs: [{ name: 'tokenId', type: 'uint256' }],
    outputs: [{
      type: 'tuple',
      components: [
        { name: 'tokenId', type: 'uint256' },
        { name: 'device', type: 'address' },
        { name: 'traceTokenId', type: 'uint256' },
        { name: 'batchId', type: 'uint256' },
        { name: 'timestamp', type: 'uint256' },
        { name: 'breachType', type: 'string' },
        { name: 'metadataURI', type: 'string' }
      ]
    }]
  },
  {
    type: 'function',
    name: 'getTotalBreaches',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }]
  },
  {
    type: 'function',
    name: 'getBreachesByProduct',
    stateMutability: 'view',
    inputs: [{ name: 'traceTokenId', type: 'uint256' }],
    outputs: [{ type: 'uint256[]' }]
  },
  {
    type: 'function',
    name: 'getRecentBreaches',
    stateMutability: 'view',
    inputs: [{ name: 'count', type: 'uint256' }],
    outputs: [{ type: 'uint256[]' }]
  }
];

// ===== Network config
const CHAIN = {
  id: 252501,
  name: "DIDLab",
  rpc: "https://eth.didlab.org"
};

// ===== UI elements
const el = id => document.getElementById(id);
const apiUrlInput = el("apiUrl");
const deviceRegistryInput = el("deviceRegistryAddr");
const dataAnchorInput = el("dataAnchorAddr");
const breachNFTInput = el("breachNFTAddr");
const acctEl = el("acct");
const netEl = el("net");
const backendStatusEl = el("backendStatus");
const totalDevicesEl = el("totalDevices");
const totalBatchesEl = el("totalBatches");
const totalBreachesEl = el("totalBreaches");
const txlog = el("txlog");

// ===== State
let chain, deviceRegistryAddr, dataAnchorAddr, breachNFTAddr, apiUrl;
let walletClient, publicClient, account;
let queueInterval;

// ===== Load/save prefs
const saved = JSON.parse(localStorage.getItem("sensorseal-ui") || "{}");
if (saved.apiUrl) apiUrlInput.value = saved.apiUrl;
if (saved.deviceRegistry) deviceRegistryInput.value = saved.deviceRegistry;
if (saved.dataAnchor) dataAnchorInput.value = saved.dataAnchor;
if (saved.breachNFT) breachNFTInput.value = saved.breachNFT;

function save() {
  localStorage.setItem("sensorseal-ui", JSON.stringify({
    apiUrl: apiUrlInput.value,
    deviceRegistry: deviceRegistryInput.value,
    dataAnchor: dataAnchorInput.value,
    breachNFT: breachNFTInput.value
  }));
}

// ===== Small logging helpers (essential)
function log(msg, cls = "") {
  try {
    const line = document.createElement("div");
    if (cls) line.classList.add(cls);
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    txlog.prepend(line);
  } catch (e) {
    // fallback console
    console.log(msg);
  }
}
const logOk = (m) => log(m, "ok");
const logWarn = (m) => log(m, "warn");
const logErr = (m) => log(m, "err");

// ===== Chain helpers
function hexChainId(id) {
  return "0x" + id.toString(16);
}

async function ensureMetamask() {
  if (!window.ethereum) throw new Error("MetaMask not found");
}

async function addOrSwitchNetwork() {
  const params = [{
    chainId: hexChainId(CHAIN.id),
    chainName: CHAIN.name,
    rpcUrls: [CHAIN.rpc],
    nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 }
  }];
  
  try {
    await window.ethereum.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: params[0].chainId }]
    });
  } catch (e) {
    await window.ethereum.request({
      method: "wallet_addEthereumChain",
      params
    });
  }
}

async function connect() {
  try {
    await ensureMetamask();
    chain = {
      id: CHAIN.id,
      name: CHAIN.name,
      nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
      rpcUrls: { default: { http: [CHAIN.rpc] } }
    };
    
    walletClient = createWalletClient({
      chain,
      transport: custom(window.ethereum)
    });
    publicClient = createPublicClient({
      chain,
      transport: custom(window.ethereum)
    });
    
    await addOrSwitchNetwork();
    const addrs = await window.ethereum.request({ method: "eth_requestAccounts" });
    account = getAddress(addrs[0]);
    
    acctEl.textContent = account;
    netEl.textContent = `${chain.name} (#${chain.id})`;
    logOk("‚úì Connected to wallet");
  } catch (e) {
    logErr("Wallet connect error: " + (e.message || e));
  }
}

async function loadContracts() {
  try {
    deviceRegistryAddr = getAddress(deviceRegistryInput.value.trim());
    dataAnchorAddr = getAddress(dataAnchorInput.value.trim());
    breachNFTAddr = getAddress(breachNFTInput.value.trim());
    apiUrl = apiUrlInput.value.trim();
    save();
    
    logOk(`‚úì Loaded contracts`);
    await checkBackend();
    await refresh();
    await loadDevices();
  } catch (e) {
    logErr("Load contracts error: " + (e.message || e));
  }
}

async function checkBackend() {
  try {
    const res = await fetch(`${apiUrl}/health`);
    const data = await res.json();
    backendStatusEl.innerHTML = `<span class="ok">‚úì Online</span> (${data.queuedReadings} queued, ${data.batchesCommitted} batches)`;
  } catch (e) {
    backendStatusEl.innerHTML = `<span class="err">‚úó Offline</span>`;
  }
}

async function refresh() {
  if (!deviceRegistryAddr || !dataAnchorAddr || !breachNFTAddr) return;
  
  try {
    const totalDevices = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getTotalDevices"
    });
    totalDevicesEl.textContent = totalDevices.toString();
    
    const totalBatches = await publicClient.readContract({
      address: dataAnchorAddr,
      abi: DATA_ANCHOR_ABI,
      functionName: "getTotalBatches"
    });
    totalBatchesEl.textContent = totalBatches.toString();
    
    const totalBreaches = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getTotalBreaches"
    });
    totalBreachesEl.textContent = totalBreaches.toString();
    
    await checkBackend();
  } catch (e) {
    logErr("Refresh error: " + (e.message || e));
  }
}

// ===== Device functions
async function loadDevices() {
  try {
    const total = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getTotalDevices"
    });
    
    if (total === 0n) {
      el("devicesTable").innerHTML = "<p class='muted'>No devices registered yet.</p>";
      return;
    }
    
    let html = "<table><thead><tr><th>Device</th><th>Owner</th><th>Trace Token ID</th><th>Status</th><th>Registered</th><th>Chart</th></tr></thead><tbody>";

    for (let i = 0; i < Number(total); i++) {
      const addr = await publicClient.readContract({
        address: deviceRegistryAddr,
        abi: DEVICE_REGISTRY_ABI,
        functionName: "getDeviceByIndex",
        args: [BigInt(i)]
      });
      
      const device = await publicClient.readContract({
        address: deviceRegistryAddr,
        abi: DEVICE_REGISTRY_ABI,
        functionName: "getDevice",
        args: [addr]
      });
      
      const status = device.active ? '<span class="ok">üü¢ Active</span>' : '<span class="err">üî¥ Inactive</span>';
      const date = new Date(Number(device.registeredAt) * 1000).toLocaleString();
      
      html += `<tr>
        <td class="mono">${String(addr).slice(0, 10)}...</td>
        <td class="mono">${String(device.owner).slice(0, 10)}...</td>
        <td>${device.traceTokenId.toString()}</td>
        <td>${status}</td>
        <td>${date}</td>
        <td><button class="small" onclick="document.getElementById('chartDeviceAddr').value='${addr}'; document.querySelector('[data-tab=device-chart]').click(); loadDeviceChart();">üìä</button></td>
      </tr>`;
    }
    
    html += "</tbody></table>";
    el("devicesTable").innerHTML = html;
  } catch (e) {
    logErr("Load devices error: " + (e.message || e));
  }
}

async function registerDevice() {
  try {
    const deviceAddr = getAddress(el("regDeviceAddr").value.trim());
    const owner = getAddress(el("regOwner").value.trim());
    const metadataCID = el("regMetadataCID").value.trim();
    const traceTokenId = BigInt(el("regTraceTokenId").value);
    
    const hash = await walletClient.writeContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "addDevice",
      args: [deviceAddr, owner, metadataCID, traceTokenId],
      account,
      gas: 500000n,
      gasPrice: 20000000000n
    });
    
    logWarn(`Device registration tx: ${hash}`);
    const rcpt = await publicClient.waitForTransactionReceipt({ hash });
    logOk(`‚úì Device registered in block ${rcpt.blockNumber}`);
    await loadDevices();
    await refresh();
  } catch (e) {
    logErr("Register device error: " + (e.message || e));
  }
}

// ===== Batch functions
async function loadBatches() {
  try {
    const total = await publicClient.readContract({
      address: dataAnchorAddr,
      abi: DATA_ANCHOR_ABI,
      functionName: "getTotalBatches"
    });
    
    if (total === 0n) {
      el("batchesTable").innerHTML = "<p class='muted'>No batches committed yet.</p>";
      return;
    }
    
    let html = "<table><thead><tr><th>Batch ID</th><th>Device</th><th>CID Hash</th><th>Window</th><th>Block</th></tr></thead><tbody>";
    
    // Get batches from blockchain
    for (let i = 0; i < Number(total); i++) {
      const batch = await publicClient.readContract({
        address: dataAnchorAddr,
        abi: DATA_ANCHOR_ABI,
        functionName: "getBatch",
        args: [BigInt(i)]
      });
      
      const start = new Date(Number(batch.windowStart) * 1000).toLocaleTimeString();
      const end = new Date(Number(batch.windowEnd) * 1000).toLocaleTimeString();
      
      html += `<tr>
        <td>${i}</td>
        <td class="mono">${String(batch.device).slice(0, 10)}...</td>
        <td class="mono">${String(batch.cidHash).slice(0, 18)}...</td>
        <td class="small">${start} - ${end}</td>
        <td>${batch.blockNumber.toString()}</td>
      </tr>`;
    }
    
    html += "</tbody></table>";
    el("batchesTable").innerHTML = html;
  } catch (e) {
    logErr("Failed to load batches: " + (e.message || e));
  }
}

async function verifyBatch() {
  const batchIdRaw = el("verifyBatchId").value;
  if (!batchIdRaw) {
    el("verifyResult").innerHTML = `<div class="verify-result error">Please enter a batch id</div>`;
    return;
  }
  const batchId = BigInt(batchIdRaw);
  const resultDiv = el("verifyResult");
  resultDiv.innerHTML = "<p class='muted'>Verifying...</p>";
  
  try {
    // Get on-chain batch
    const batch = await publicClient.readContract({
      address: dataAnchorAddr,
      abi: DATA_ANCHOR_ABI,
      functionName: "getBatch",
      args: [batchId]
    });
    
    // Get backend batches to find CID
    const res = await fetch(`${apiUrl}/batches`);
    const batches = await res.json();
    const batchData = batches.find(b => b.blockNumber === batch.blockNumber.toString());
    
    if (!batchData) {
      resultDiv.innerHTML = '<div class="verify-result error">‚ö† Batch found on-chain but not in backend history</div>';
      return;
    }
    
    // Compute hash of CID
    const { keccak256, toHex } = await import('https://esm.sh/viem@2.37.5');
    const computedHash = keccak256(toHex(batchData.cid));
    
    // Compare
    if (String(computedHash).toLowerCase() === String(batch.cidHash).toLowerCase()) {
      resultDiv.innerHTML = `
        <div class="verify-result success">
          <h4>‚úÖ VERIFIED</h4>
          <p><strong>CID:</strong> ${batchData.cid}</p>
          <p><strong>Hash Match:</strong> ${computedHash}</p>
          <p><strong>Device:</strong> ${batch.device}</p>
          <p><strong>Timestamp:</strong> ${new Date(Number(batch.timestamp) * 1000).toLocaleString()}</p>
          <p><a href="https://ipfs.io/ipfs/${batchData.cid}" target="_blank">View on IPFS ‚Üí</a></p>
        </div>
      `;
    } else {
      resultDiv.innerHTML = `
        <div class="verify-result error">
          <h4>‚ö† TAMPERING DETECTED</h4>
          <p><strong>Expected:</strong> ${batch.cidHash}</p>
          <p><strong>Computed:</strong> ${computedHash}</p>
        </div>
      `;
    }
  } catch (e) {
    resultDiv.innerHTML = `<div class="verify-result error">Error: ${e.message}</div>`;
  }
}

// ===== Breach functions
async function loadBreaches() {
  try {
    const tokenIds = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getRecentBreaches",
      args: [10n]
    });
    
    if (!tokenIds || tokenIds.length === 0) {
      el("breachesTable").innerHTML = "<p class='muted'>No breaches detected yet. üéâ</p>";
      return;
    }
    
    let html = "";
    
    for (const tokenId of tokenIds) {
      const breach = await publicClient.readContract({
        address: breachNFTAddr,
        abi: BREACH_NFT_ABI,
        functionName: "getBreachInfo",
        args: [tokenId]
      });
      
      const date = new Date(Number(breach.timestamp) * 1000).toLocaleString();
      const ipfsLink = String(breach.metadataURI).replace("ipfs://", "");
      
      html += `
        <div class="breach-card">
          <h4>üî¥ Breach NFT #${tokenId.toString()}</h4>
          <div class="kvs">
            <div class="muted">Device</div><div class="mono">${breach.device}</div>
            <div class="muted">Product (traceToken)</div><div>${breach.traceTokenId.toString()}</div>
            <div class="muted">Batch</div><div>${breach.batchId.toString()}</div>
            <div class="muted">When</div><div>${date}</div>
            <div class="muted">Type</div><div>${breach.breachType}</div>
            <div class="muted">Report</div><div><a href="https://ipfs.io/ipfs/${ipfsLink}" target="_blank">${ipfsLink.slice(0,18)}...</a></div>
          </div>
        </div>
      `;
    }
    
    el("breachesTable").innerHTML = html;
  } catch (e) {
    logErr("Failed to load breaches: " + (e.message || e));
  }
}

async function checkProduct() {
  try {
    const traceIdRaw = el("checkProductId").value;
    if (!traceIdRaw) {
      el("productBreachResult").innerHTML = "<p class='muted'>Enter a product trace token id</p>";
      return;
    }
    const traceId = BigInt(traceIdRaw);
    
    const breachIds = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getBreachesByProduct",
      args: [traceId]
    });
    
    if (!breachIds || breachIds.length === 0) {
      el("productBreachResult").innerHTML = `<div class="verify-result success">No breaches for product ${traceId.toString()}</div>`;
      return;
    }
    
    const list = Array.from(breachIds).map(id => `#${id.toString()}`).join(", ");
    el("productBreachResult").innerHTML = `<div class="verify-result error">Breaches found: ${list}</div>`;
  } catch (e) {
    el("productBreachResult").innerHTML = `<div class="verify-result error">Error: ${e.message}</div>`;
  }
}

// ===== Minimal queue/health loader (essential)
async function loadQueue() {
  if (!apiUrl) return;
  try {
    const res = await fetch(`${apiUrl}/health`);
    const d = await res.json();
    el("queueStatus").innerHTML = `<p class="small">Queued: ${d.queuedReadings} ¬∑ Batches: ${d.batchesCommitted}</p>`;
    el("healthStatus").innerHTML = `<p class="small">Backend last checked: ${new Date().toLocaleTimeString()}</p>`;
  } catch (e) {
    el("queueStatus").innerHTML = `<p class="err">Backend offline</p>`;
    el("healthStatus").innerHTML = `<p class="err">Backend offline</p>`;
  }
}

// ===== Tab navigation (essential)
document.querySelectorAll(".tab").forEach(tab => {
  tab.addEventListener("click", () => {
    document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    tab.classList.add("active");
    const name = tab.dataset.tab;
    const target = document.getElementById("tab-" + name);
    if (target) target.classList.add("active");
  });
});

// ===== Chart functions
let deviceChartInstance = null;

async function loadDeviceChart() {
  try {
    const deviceAddr = getAddress(el("chartDeviceAddr").value.trim());
    
    // Fetch batches from backend
    const res = await fetch(`${apiUrl}/batches`);
    const batches = await res.json();
    
    // Filter batches for this device
    const deviceBatches = batches.filter(b => 
      b.device.toLowerCase() === deviceAddr.toLowerCase()
    );
    
    if (deviceBatches.length === 0) {
      el("chartStats").innerHTML = "No data found for this device";
      return;
    }
    
    // Fetch IPFS data for each batch to get readings
    let allReadings = [];
    for (const batch of deviceBatches) {
      try {
        const ipfsRes = await fetch(`https://ipfs.io/ipfs/${batch.cid}`);
        const batchData = await ipfsRes.json();
        if (batchData.readings) {
          allReadings = allReadings.concat(batchData.readings);
        }
      } catch (e) {
        console.warn(`Failed to fetch IPFS data for ${batch.cid}`);
      }
    }
    
    if (allReadings.length === 0) {
      el("chartStats").innerHTML = "No readings found in batches";
      return;
    }
    
    // Sort by timestamp
    allReadings.sort((a, b) => a.t - b.t);
    
    // Prepare chart data
    const labels = allReadings.map(r => new Date(r.t * 1000).toLocaleTimeString());
    const temps = allReadings.map(r => r.temp);
    const hums = allReadings.map(r => r.hum);
    
    // Destroy existing chart if any
    if (deviceChartInstance) {
      deviceChartInstance.destroy();
    }
    
    // Create chart
    const ctx = el("deviceChart").getContext("2d");
    deviceChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Temperature (¬∞C)',
            data: temps,
            borderColor: '#ff6b6b',
            backgroundColor: 'rgba(255, 107, 107, 0.1)',
            yAxisID: 'y',
            tension: 0.4
          },
          {
            label: 'Humidity (%)',
            data: hums,
            borderColor: '#4ecdc4',
            backgroundColor: 'rgba(78, 205, 196, 0.1)',
            yAxisID: 'y1',
            tension: 0.4
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        plugins: {
          legend: {
            labels: { color: '#e6eaf2' }
          }
        },
        scales: {
          x: {
            ticks: { color: '#8a9bb8' },
            grid: { color: '#24314a' }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: { display: true, text: 'Temperature (¬∞C)', color: '#e6eaf2' },
            ticks: { color: '#ff6b6b' },
            grid: { color: '#24314a' }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            title: { display: true, text: 'Humidity (%)', color: '#e6eaf2' },
            ticks: { color: '#4ecdc4' },
            grid: { drawOnChartArea: false }
          }
        }
      }
    });
    
    // Stats
    const avgTemp = (temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1);
    const minTemp = Math.min(...temps).toFixed(1);
    const maxTemp = Math.max(...temps).toFixed(1);
    const breaches = temps.filter(t => t < 2 || t > 8).length;
    
    el("chartStats").innerHTML = `
      üìä ${allReadings.length} readings | 
      Avg: ${avgTemp}¬∞C | 
      Range: ${minTemp}¬∞C - ${maxTemp}¬∞C | 
      Breaches: ${breaches}
    `;
    
    logOk(`Loaded ${allReadings.length} readings for device chart`);
  } catch (e) {
    logErr("Chart load error: " + (e.message || e));
  }
}

async function loadProductView() {
  try {
    const traceId = BigInt(el("productViewId").value);
    const contentDiv = el("productViewContent");
    contentDiv.innerHTML = "<p class='muted'>Loading...</p>";
    
    // Get devices for this product
    const devices = await publicClient.readContract({
      address: deviceRegistryAddr,
      abi: DEVICE_REGISTRY_ABI,
      functionName: "getDevicesByProduct",
      args: [traceId]
    });
    
    if (!devices || devices.length === 0) {
      contentDiv.innerHTML = "<p class='muted'>No devices monitoring this product</p>";
      return;
    }
    
    // Get breaches for this product
    const breachIds = await publicClient.readContract({
      address: breachNFTAddr,
      abi: BREACH_NFT_ABI,
      functionName: "getBreachesByProduct",
      args: [traceId]
    });
    
    let html = `<h4>Product Trace Token #${traceId.toString()}</h4>`;
    
    // Status badge
    if (!breachIds || breachIds.length === 0) {
      html += `<div class="badge badge-good">‚úì NO BREACHES DETECTED</div>`;
    } else {
      html += `<div class="badge badge-breach">‚ö† ${breachIds.length} BREACH(ES) DETECTED</div>`;
    }
    
    html += "<h4 style='margin-top: 20px;'>Monitoring Devices</h4>";
    html += "<table><thead><tr><th>Device</th><th>Owner</th><th>Status</th><th>Actions</th></tr></thead><tbody>";
    
    for (const deviceAddr of devices) {
      const device = await publicClient.readContract({
        address: deviceRegistryAddr,
        abi: DEVICE_REGISTRY_ABI,
        functionName: "getDevice",
        args: [deviceAddr]
      });
      
      const status = device.active ? '<span class="ok">üü¢ Active</span>' : '<span class="err">üî¥ Inactive</span>';
      
      html += `<tr>
        <td class="mono">${String(deviceAddr).slice(0, 16)}...</td>
        <td class="mono">${String(device.owner).slice(0, 16)}...</td>
        <td>${status}</td>
        <td><button class="small" onclick="document.getElementById('chartDeviceAddr').value='${deviceAddr}'; document.querySelector('[data-tab=device-chart]').click(); loadDeviceChart();">View Chart</button></td>
      </tr>`;
    }
    
    html += "</tbody></table>";
    
    // Show breaches if any
    if (breachIds && breachIds.length > 0) {
      html += "<h4 style='margin-top: 20px;'>Breach History</h4>";
      
      for (const tokenId of breachIds) {
        const breach = await publicClient.readContract({
          address: breachNFTAddr,
          abi: BREACH_NFT_ABI,
          functionName: "getBreachInfo",
          args: [tokenId]
        });
        
        const date = new Date(Number(breach.timestamp) * 1000).toLocaleString();
        const ipfsLink = String(breach.metadataURI).replace("ipfs://", "");
        
        html += `
          <div class="breach-card" style="margin-top: 8px;">
            <strong>Breach NFT #${tokenId.toString()}</strong> - ${breach.breachType}<br>
            <span class="small">Device: ${String(breach.device).slice(0, 16)}... | ${date}</span><br>
            <a href="https://ipfs.io/ipfs/${ipfsLink}" target="_blank">View Report ‚Üí</a>
          </div>
        `;
      }
    }
    
    contentDiv.innerHTML = html;
    logOk(`Loaded product view for trace token ${traceId.toString()}`);
  } catch (e) {
    logErr("Product view error: " + (e.message || e));
    el("productViewContent").innerHTML = `<p class="err">Error: ${e.message}</p>`;
  }
}

// Add missing ABI function for getDevicesByProduct
DEVICE_REGISTRY_ABI.push({
  type: 'function',
  name: 'getDevicesByProduct',
  stateMutability: 'view',
  inputs: [{ name: 'traceTokenId', type: 'uint256' }],
  outputs: [{ type: 'address[]' }]
});

// ===== Button wiring (essential)
el("btnConnect").addEventListener("click", connect);
el("btnLoad").addEventListener("click", loadContracts);
el("btnRefresh").addEventListener("click", refresh);
el("btnRegister").addEventListener("click", registerDevice);
el("btnLoadBatches").addEventListener("click", loadBatches);
el("btnVerify").addEventListener("click", verifyBatch);
el("btnLoadBreaches").addEventListener("click", loadBreaches);
el("btnCheckProduct").addEventListener("click", checkProduct);
el("btnLoadChart").addEventListener("click", loadDeviceChart);
el("btnLoadProduct").addEventListener("click", loadProductView);

// Start minimal periodic queue loader (bare minimum, 5s)
queueInterval = setInterval(() => {
  try { loadQueue(); } catch (e) { /* noop */ }
}, 5000);

// End of script
</script>